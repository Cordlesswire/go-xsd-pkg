// Package goSamlDce20 : autogenerated by go-xsd
package goSamlDce20

//	Document identifier: saml-schema-dce-2.0 Location: http://docs.oasis-open.org/security/saml/v2.0/ Revision history: V2.0 (March, 2005): Custom schema for DCE attribute profile, first published in SAML 2.0.

import (
	xsdt "github.com/miracl/go-xsd-pkg/xsdt"
)

// XsdGoPkgHasAttrRealm defines attribute Realm
type XsdGoPkgHasAttrRealm struct {
	Realm xsdt.AnyURI `xml:"urn:oasis:names:tc:SAML:2.0:profiles:attribute:DCE Realm,attr"`
}

// XsdGoPkgHasAttrFriendlyName defines attribute FriendlyName
type XsdGoPkgHasAttrFriendlyName struct {
	FriendlyName xsdt.String `xml:"urn:oasis:names:tc:SAML:2.0:profiles:attribute:DCE FriendlyName,attr"`
}

// XsdGoPkgHasAnyURICdata defines XsdGoPkgHasAnyURICdata
type XsdGoPkgHasAnyURICdata struct {
	XsdGoPkgCDATA xsdt.AnyURI `xml:",chardata"`
}

// TDCEValueType defines TDCEValueType
type TDCEValueType struct {
	XsdGoPkgHasAnyURICdata

	XsdGoPkgHasAttrRealm

	XsdGoPkgHasAttrFriendlyName
}

// Walk : if the WalkHandlers.TDCEValueType function is not nil (ie. was set by outside code), calls it with this TDCEValueType instance as the single argument. Then calls the Walk() method on 0/3 embed(s) and 0/0 field(s) belonging to this TDCEValueType instance.
func (me *TDCEValueType) Walk() (err error) {
	if fn := WalkHandlers.TDCEValueType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XsdGoPkgHasCdata defines type CDATA
type XsdGoPkgHasCdata struct {
	XsdGoPkgCDATA string `xml:",chardata"`
}

// Walk : if the WalkHandlers.XsdGoPkgHasCdata function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasCdata instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasCdata instance.
func (me *XsdGoPkgHasCdata) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasCdata; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

var (
	// WalkContinueOnError can be set to false to break a Walk() immediately as soon as the first error is returned by a custom handler function.
	// If true, Walk() proceeds and accumulates all errors in the WalkErrors slice.
	WalkContinueOnError = true
	// WalkErrors contains all errors accumulated during Walk()s. If you're using this, you need to reset this yourself as needed prior to a fresh Walk().
	WalkErrors []error
	// WalkOnError is your custom error-handling function, if required.
	WalkOnError func(error)
	// WalkHandlers Provides 2 strong-typed hooks for your own custom handler functions to be invoked when the Walk() method is called on any instance of any (non-attribute-related) struct type defined in this package.
	// If your custom handler does get called at all for a given struct instance, then it always gets called twice, first with the 'enter' bool argument set to true, then (after having Walk()ed all subordinate struct instances, if any) once again with it set to false.
	WalkHandlers = &XsdGoPkgWalkHandlers{}
)

// XsdGoPkgWalkHandlers Provides 2 strong-typed hooks for your own custom handler functions to be invoked when the Walk() method is called on any instance of any (non-attribute-related) struct type defined in this package.
// If your custom handler does get called at all for a given struct instance, then it always gets called twice, first with the 'enter' bool argument set to true, then (after having Walk()ed all subordinate struct instances, if any) once again with it set to false.
type XsdGoPkgWalkHandlers struct {
	TDCEValueType    func(*TDCEValueType, bool) error
	XsdGoPkgHasCdata func(*XsdGoPkgHasCdata, bool) error
}
