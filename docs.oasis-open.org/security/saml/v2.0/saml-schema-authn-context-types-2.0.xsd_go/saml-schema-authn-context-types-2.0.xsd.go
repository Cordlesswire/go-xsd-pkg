//	Auto-generated by the "go-xsd" package located at:
//		github.com/miracl/go-xsd
//	Comments on types and fields (if any) are from the XSD file located at:
//		docs.oasis-open.org/security/saml/v2.0/saml-schema-authn-context-types-2.0.xsd
package go_SamlAuthnContextTypes20

//	Document identifier: saml-schema-authn-context-types-2.0
//	Location: http://docs.oasis-open.org/security/saml/v2.0/
//	Revision history:
//	V2.0 (March, 2005):
//	New core authentication context schema types for SAML V2.0.

import (
	xsdt "github.com/miracl/go-xsd-pkg/xsdt"
)

//	A particular assertion on an identity
//	provider's part with respect to the authentication
//	context associated with an authentication assertion.
//	Provides a mechanism for linking to external (likely
//	human readable) documents in which additional business agreements,
//	(e.g. liability constraints, obligations, etc) can be placed.
type XsdGoPkgHasAttr_GoverningAgreementRef_XsdtAnyURI_ struct {
	GoverningAgreementRef xsdt.AnyURI `xml:"governingAgreementRef,attr"`
}

type TGoverningAgreementRefType struct {
	XsdGoPkgHasAttr_GoverningAgreementRef_XsdtAnyURI_
}

//	If the WalkHandlers.TGoverningAgreementRefType function is not nil (ie. was set by outside code), calls it with this TGoverningAgreementRefType instance as the single argument. Then calls the Walk() method on 0/1 embed(s) and 0/0 field(s) belonging to this TGoverningAgreementRefType instance.
func (me *TGoverningAgreementRefType) Walk() (err error) {
	if fn := WalkHandlers.TGoverningAgreementRefType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_GoverningAgreementRef struct {
	GoverningAgreementRefs []*TGoverningAgreementRefType `xml:"GoverningAgreementRef"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_GoverningAgreementRef function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_GoverningAgreementRef instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_GoverningAgreementRef instance.
func (me *XsdGoPkgHasElems_GoverningAgreementRef) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_GoverningAgreementRef; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.GoverningAgreementRefs {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TGoverningAgreementsType struct {
	XsdGoPkgHasElems_GoverningAgreementRef
}

//	If the WalkHandlers.TGoverningAgreementsType function is not nil (ie. was set by outside code), calls it with this TGoverningAgreementsType instance as the single argument. Then calls the Walk() method on 1/1 embed(s) and 0/0 field(s) belonging to this TGoverningAgreementsType instance.
func (me *TGoverningAgreementsType) Walk() (err error) {
	if fn := WalkHandlers.TGoverningAgreementsType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElems_GoverningAgreementRef.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_GoverningAgreements struct {
	//	Provides a mechanism for linking to external (likely
	//	human readable) documents in which additional business agreements,
	//	(e.g. liability constraints, obligations, etc) can be placed.
	GoverningAgreements *TGoverningAgreementsType `xml:"GoverningAgreements"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_GoverningAgreements function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_GoverningAgreements instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_GoverningAgreements instance.
func (me *XsdGoPkgHasElem_GoverningAgreements) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_GoverningAgreements; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.GoverningAgreements.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TExtensionType struct {
}

//	If the WalkHandlers.TExtensionType function is not nil (ie. was set by outside code), calls it with this TExtensionType instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/0 field(s) belonging to this TExtensionType instance.
func (me *TExtensionType) Walk() (err error) {
	if fn := WalkHandlers.TExtensionType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_Extension struct {
	Extensions []*TExtensionType `xml:"Extension"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_Extension function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_Extension instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_Extension instance.
func (me *XsdGoPkgHasElems_Extension) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_Extension; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Extensions {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasAttr_Id_XsdtId_ struct {
	Id xsdt.Id `xml:"ID,attr"`
}

//	Refers to those characteristics that describe the
//	processes and mechanisms
//	the Authentication Authority uses to initially create
//	an association between a Principal
//	and the identity (or name) by which the Principal will
//	be known
//	This element indicates that identification has been
//	performed in a physical
//	face-to-face meeting with the principal and not in an
//	online manner.
type TxsdPhysicalVerificationCredentialLevel xsdt.Nmtoken

//	Returns true if the value of this enumerated TxsdPhysicalVerificationCredentialLevel is "primary".
func (me TxsdPhysicalVerificationCredentialLevel) IsPrimary() bool { return me.String() == "primary" }

//	Returns true if the value of this enumerated TxsdPhysicalVerificationCredentialLevel is "secondary".
func (me TxsdPhysicalVerificationCredentialLevel) IsSecondary() bool {
	return me.String() == "secondary"
}

//	Since TxsdPhysicalVerificationCredentialLevel is just a simple String type, this merely sets the current value from the specified string.
func (me *TxsdPhysicalVerificationCredentialLevel) Set(s string) { (*xsdt.Nmtoken)(me).Set(s) }

//	Since TxsdPhysicalVerificationCredentialLevel is just a simple String type, this merely returns the current string value.
func (me TxsdPhysicalVerificationCredentialLevel) String() string { return xsdt.Nmtoken(me).String() }

//	This convenience method just performs a simple type conversion to TxsdPhysicalVerificationCredentialLevel's alias type xsdt.Nmtoken.
func (me TxsdPhysicalVerificationCredentialLevel) ToXsdtNmtoken() xsdt.Nmtoken {
	return xsdt.Nmtoken(me)
}

type XsdGoPkgHasAttr_CredentialLevel_TxsdPhysicalVerificationCredentialLevel_ struct {
	CredentialLevel TxsdPhysicalVerificationCredentialLevel `xml:"credentialLevel,attr"`
}

type TxsdPhysicalVerification struct {
	XsdGoPkgHasAttr_CredentialLevel_TxsdPhysicalVerificationCredentialLevel_
}

//	If the WalkHandlers.TxsdPhysicalVerification function is not nil (ie. was set by outside code), calls it with this TxsdPhysicalVerification instance as the single argument. Then calls the Walk() method on 0/1 embed(s) and 0/0 field(s) belonging to this TxsdPhysicalVerification instance.
func (me *TxsdPhysicalVerification) Walk() (err error) {
	if fn := WalkHandlers.TxsdPhysicalVerification; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_PhysicalVerification struct {
	//	This element indicates that identification has been
	//	performed in a physical
	//	face-to-face meeting with the principal and not in an
	//	online manner.
	PhysicalVerification *TxsdPhysicalVerification `xml:"PhysicalVerification"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_PhysicalVerification function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_PhysicalVerification instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_PhysicalVerification instance.
func (me *XsdGoPkgHasElem_PhysicalVerification) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_PhysicalVerification; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.PhysicalVerification.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TExtensionOnlyType struct {
	XsdGoPkgHasElems_Extension
}

//	If the WalkHandlers.TExtensionOnlyType function is not nil (ie. was set by outside code), calls it with this TExtensionOnlyType instance as the single argument. Then calls the Walk() method on 1/1 embed(s) and 0/0 field(s) belonging to this TExtensionOnlyType instance.
func (me *TExtensionOnlyType) Walk() (err error) {
	if fn := WalkHandlers.TExtensionOnlyType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElems_Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_WrittenConsent struct {
	WrittenConsent *TExtensionOnlyType `xml:"WrittenConsent"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_WrittenConsent function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_WrittenConsent instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_WrittenConsent instance.
func (me *XsdGoPkgHasElem_WrittenConsent) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_WrittenConsent; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.WrittenConsent.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This attribute indicates whether or not the
//	Identification mechanisms allow the actions of the Principal to be
//	linked to an actual end user.
type TnymType xsdt.Nmtoken

//	Since TnymType is just a simple String type, this merely sets the current value from the specified string.
func (me *TnymType) Set(s string) { (*xsdt.Nmtoken)(me).Set(s) }

//	Since TnymType is just a simple String type, this merely returns the current string value.
func (me TnymType) String() string { return xsdt.Nmtoken(me).String() }

//	This convenience method just performs a simple type conversion to TnymType's alias type xsdt.Nmtoken.
func (me TnymType) ToXsdtNmtoken() xsdt.Nmtoken { return xsdt.Nmtoken(me) }

//	Returns true if the value of this enumerated TnymType is "anonymity".
func (me TnymType) IsAnonymity() bool { return me.String() == "anonymity" }

//	Returns true if the value of this enumerated TnymType is "verinymity".
func (me TnymType) IsVerinymity() bool { return me.String() == "verinymity" }

//	Returns true if the value of this enumerated TnymType is "pseudonymity".
func (me TnymType) IsPseudonymity() bool { return me.String() == "pseudonymity" }

type XsdGoPkgHasAttr_Nym_TnymType_ struct {
	//	This attribute indicates whether or not the
	//	Identification mechanisms allow the actions of the Principal to be
	//	linked to an actual end user.
	Nym TnymType `xml:"nym,attr"`
}

type TIdentificationType struct {
	XsdGoPkgHasElem_WrittenConsent

	XsdGoPkgHasElem_GoverningAgreements

	XsdGoPkgHasElems_Extension

	//	This attribute indicates whether or not the
	//	Identification mechanisms allow the actions of the Principal to be
	//	linked to an actual end user.
	XsdGoPkgHasAttr_Nym_TnymType_

	XsdGoPkgHasElem_PhysicalVerification
}

//	If the WalkHandlers.TIdentificationType function is not nil (ie. was set by outside code), calls it with this TIdentificationType instance as the single argument. Then calls the Walk() method on 4/5 embed(s) and 0/0 field(s) belonging to this TIdentificationType instance.
func (me *TIdentificationType) Walk() (err error) {
	if fn := WalkHandlers.TIdentificationType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElem_PhysicalVerification.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_WrittenConsent.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_GoverningAgreements.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_Identification struct {
	//	Refers to those characteristics that describe the
	//	processes and mechanisms
	//	the Authentication Authority uses to initially create
	//	an association between a Principal
	//	and the identity (or name) by which the Principal will
	//	be known
	Identification *TIdentificationType `xml:"Identification"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_Identification function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_Identification instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_Identification instance.
func (me *XsdGoPkgHasElem_Identification) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_Identification; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Identification.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Refers to those characterstics that describe how the
//	'secret' (the knowledge or possession
//	of which allows the Principal to authenticate to the
//	Authentication Authority) is kept secure
//	This element indicates the types and strengths of
//	facilities
//	of a UA used to protect a shared secret key from
//	unauthorized access and/or use.
//	The actions that must be performed
//	before the private key can be used.
//	This element indicates that a Pin (Personal
//	Identification Number) has been used to authenticate the Principal to
//	some local system in order to activate a key.
//	This element indicates the minimum and/or maximum
//	ASCII length of the password which is enforced (by the UA or the
//	IdP). In other words, this is the minimum and/or maximum number of
//	ASCII characters required to represent a valid password.
//	min - the minimum number of ASCII characters required
//	in a valid password, as enforced by the UA or the IdP.
//	max - the maximum number of ASCII characters required
//	in a valid password, as enforced by the UA or the IdP.
type XsdGoPkgHasAttr_Max_XsdtInteger_ struct {
	Max xsdt.Integer `xml:"max,attr"`
}

type XsdGoPkgHasAttr_Min_XsdtInteger_ struct {
	Min xsdt.Integer `xml:"min,attr"`
}

type TLengthType struct {
	XsdGoPkgHasAttr_Min_XsdtInteger_

	XsdGoPkgHasAttr_Max_XsdtInteger_
}

//	If the WalkHandlers.TLengthType function is not nil (ie. was set by outside code), calls it with this TLengthType instance as the single argument. Then calls the Walk() method on 0/2 embed(s) and 0/0 field(s) belonging to this TLengthType instance.
func (me *TLengthType) Walk() (err error) {
	if fn := WalkHandlers.TLengthType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_Length struct {
	//	This element indicates the minimum and/or maximum
	//	ASCII length of the password which is enforced (by the UA or the
	//	IdP). In other words, this is the minimum and/or maximum number of
	//	ASCII characters required to represent a valid password.
	//	min - the minimum number of ASCII characters required
	//	in a valid password, as enforced by the UA or the IdP.
	//	max - the maximum number of ASCII characters required
	//	in a valid password, as enforced by the UA or the IdP.
	Length *TLengthType `xml:"Length"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_Length function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_Length instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_Length instance.
func (me *XsdGoPkgHasElem_Length) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_Length; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Length.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasAttr_ExcludedChars_XsdtString_ struct {
	ExcludedChars xsdt.String `xml:"excludedChars,attr"`
}

type XsdGoPkgHasAttr_Case_XsdtString_ struct {
	Case xsdt.String `xml:"case,attr"`
}

type XsdGoPkgHasAttr_RequiredChars_XsdtString_ struct {
	RequiredChars xsdt.String `xml:"requiredChars,attr"`
}

type TAlphabetType struct {
	XsdGoPkgHasAttr_RequiredChars_XsdtString_

	XsdGoPkgHasAttr_ExcludedChars_XsdtString_

	XsdGoPkgHasAttr_Case_XsdtString_
}

//	If the WalkHandlers.TAlphabetType function is not nil (ie. was set by outside code), calls it with this TAlphabetType instance as the single argument. Then calls the Walk() method on 0/3 embed(s) and 0/0 field(s) belonging to this TAlphabetType instance.
func (me *TAlphabetType) Walk() (err error) {
	if fn := WalkHandlers.TAlphabetType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_Alphabet struct {
	Alphabet *TAlphabetType `xml:"Alphabet"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_Alphabet function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_Alphabet instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_Alphabet instance.
func (me *XsdGoPkgHasElem_Alphabet) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_Alphabet; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Alphabet.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Indicates whether the password was chosen by the
//	Principal or auto-supplied by the Authentication Authority.
//	principalchosen - the Principal is allowed to choose
//	the value of the password. This is true even if
//	the initial password is chosen at random by the UA or
//	the IdP and the Principal is then free to change
//	the password.
//	automatic - the password is chosen by the UA or the
//	IdP to be cryptographically strong in some sense,
//	or to satisfy certain password rules, and that the
//	Principal is not free to change it or to choose a new password.
type TxsdGenerationMechanism xsdt.Nmtoken

//	Since TxsdGenerationMechanism is just a simple String type, this merely returns the current string value.
func (me TxsdGenerationMechanism) String() string { return xsdt.Nmtoken(me).String() }

//	This convenience method just performs a simple type conversion to TxsdGenerationMechanism's alias type xsdt.Nmtoken.
func (me TxsdGenerationMechanism) ToXsdtNmtoken() xsdt.Nmtoken { return xsdt.Nmtoken(me) }

//	Returns true if the value of this enumerated TxsdGenerationMechanism is "principalchosen".
func (me TxsdGenerationMechanism) IsPrincipalchosen() bool { return me.String() == "principalchosen" }

//	Returns true if the value of this enumerated TxsdGenerationMechanism is "automatic".
func (me TxsdGenerationMechanism) IsAutomatic() bool { return me.String() == "automatic" }

//	Since TxsdGenerationMechanism is just a simple String type, this merely sets the current value from the specified string.
func (me *TxsdGenerationMechanism) Set(s string) { (*xsdt.Nmtoken)(me).Set(s) }

type XsdGoPkgHasAttr_Mechanism_TxsdGenerationMechanism_ struct {
	Mechanism TxsdGenerationMechanism `xml:"mechanism,attr"`
}

type TxsdGeneration struct {
	XsdGoPkgHasAttr_Mechanism_TxsdGenerationMechanism_
}

//	If the WalkHandlers.TxsdGeneration function is not nil (ie. was set by outside code), calls it with this TxsdGeneration instance as the single argument. Then calls the Walk() method on 0/1 embed(s) and 0/0 field(s) belonging to this TxsdGeneration instance.
func (me *TxsdGeneration) Walk() (err error) {
	if fn := WalkHandlers.TxsdGeneration; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_Generation struct {
	//	Indicates whether the password was chosen by the
	//	Principal or auto-supplied by the Authentication Authority.
	//	principalchosen - the Principal is allowed to choose
	//	the value of the password. This is true even if
	//	the initial password is chosen at random by the UA or
	//	the IdP and the Principal is then free to change
	//	the password.
	//	automatic - the password is chosen by the UA or the
	//	IdP to be cryptographically strong in some sense,
	//	or to satisfy certain password rules, and that the
	//	Principal is not free to change it or to choose a new password.
	Generation *TxsdGeneration `xml:"Generation"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_Generation function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_Generation instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_Generation instance.
func (me *XsdGoPkgHasElem_Generation) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_Generation; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Generation.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates the length of time for which an
//	PIN-based authentication is valid.
//	This element indicates that the Key Activation Limit is
//	defined as a specific duration of time.
type XsdGoPkgHasAttr_Duration_XsdtDuration_ struct {
	Duration xsdt.Duration `xml:"duration,attr"`
}

type TActivationLimitDurationType struct {
	XsdGoPkgHasAttr_Duration_XsdtDuration_
}

//	If the WalkHandlers.TActivationLimitDurationType function is not nil (ie. was set by outside code), calls it with this TActivationLimitDurationType instance as the single argument. Then calls the Walk() method on 0/1 embed(s) and 0/0 field(s) belonging to this TActivationLimitDurationType instance.
func (me *TActivationLimitDurationType) Walk() (err error) {
	if fn := WalkHandlers.TActivationLimitDurationType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_ActivationLimitDuration struct {
	//	This element indicates that the Key Activation Limit is
	//	defined as a specific duration of time.
	ActivationLimitDuration *TActivationLimitDurationType `xml:"ActivationLimitDuration"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_ActivationLimitDuration function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_ActivationLimitDuration instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_ActivationLimitDuration instance.
func (me *XsdGoPkgHasElem_ActivationLimitDuration) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_ActivationLimitDuration; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.ActivationLimitDuration.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Key Activation Limit is
//	defined as a number of usages.
type XsdGoPkgHasAttr_Number_XsdtInteger_ struct {
	Number xsdt.Integer `xml:"number,attr"`
}

type TActivationLimitUsagesType struct {
	XsdGoPkgHasAttr_Number_XsdtInteger_
}

//	If the WalkHandlers.TActivationLimitUsagesType function is not nil (ie. was set by outside code), calls it with this TActivationLimitUsagesType instance as the single argument. Then calls the Walk() method on 0/1 embed(s) and 0/0 field(s) belonging to this TActivationLimitUsagesType instance.
func (me *TActivationLimitUsagesType) Walk() (err error) {
	if fn := WalkHandlers.TActivationLimitUsagesType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_ActivationLimitUsages struct {
	//	This element indicates that the Key Activation Limit is
	//	defined as a number of usages.
	ActivationLimitUsages *TActivationLimitUsagesType `xml:"ActivationLimitUsages"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_ActivationLimitUsages function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_ActivationLimitUsages instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_ActivationLimitUsages instance.
func (me *XsdGoPkgHasElem_ActivationLimitUsages) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_ActivationLimitUsages; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.ActivationLimitUsages.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Key Activation Limit is
//	the session.
type TActivationLimitSessionType struct {
}

//	If the WalkHandlers.TActivationLimitSessionType function is not nil (ie. was set by outside code), calls it with this TActivationLimitSessionType instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/0 field(s) belonging to this TActivationLimitSessionType instance.
func (me *TActivationLimitSessionType) Walk() (err error) {
	if fn := WalkHandlers.TActivationLimitSessionType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_ActivationLimitSession struct {
	//	This element indicates that the Key Activation Limit is
	//	the session.
	ActivationLimitSession *TActivationLimitSessionType `xml:"ActivationLimitSession"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_ActivationLimitSession function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_ActivationLimitSession instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_ActivationLimitSession instance.
func (me *XsdGoPkgHasElem_ActivationLimitSession) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_ActivationLimitSession; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.ActivationLimitSession.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TActivationLimitType struct {
	XsdGoPkgHasElem_ActivationLimitUsages

	XsdGoPkgHasElem_ActivationLimitSession

	XsdGoPkgHasElem_ActivationLimitDuration
}

//	If the WalkHandlers.TActivationLimitType function is not nil (ie. was set by outside code), calls it with this TActivationLimitType instance as the single argument. Then calls the Walk() method on 3/3 embed(s) and 0/0 field(s) belonging to this TActivationLimitType instance.
func (me *TActivationLimitType) Walk() (err error) {
	if fn := WalkHandlers.TActivationLimitType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElem_ActivationLimitDuration.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_ActivationLimitUsages.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_ActivationLimitSession.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_ActivationLimit struct {
	//	This element indicates the length of time for which an
	//	PIN-based authentication is valid.
	ActivationLimit *TActivationLimitType `xml:"ActivationLimit"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_ActivationLimit function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_ActivationLimit instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_ActivationLimit instance.
func (me *XsdGoPkgHasElem_ActivationLimit) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_ActivationLimit; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.ActivationLimit.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TActivationPinType struct {
	XsdGoPkgHasElem_Alphabet

	XsdGoPkgHasElem_Generation

	XsdGoPkgHasElem_ActivationLimit

	XsdGoPkgHasElems_Extension

	XsdGoPkgHasElem_Length
}

//	If the WalkHandlers.TActivationPinType function is not nil (ie. was set by outside code), calls it with this TActivationPinType instance as the single argument. Then calls the Walk() method on 5/5 embed(s) and 0/0 field(s) belonging to this TActivationPinType instance.
func (me *TActivationPinType) Walk() (err error) {
	if fn := WalkHandlers.TActivationPinType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElem_Length.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_Alphabet.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_Generation.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_ActivationLimit.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_ActivationPin struct {
	//	This element indicates that a Pin (Personal
	//	Identification Number) has been used to authenticate the Principal to
	//	some local system in order to activate a key.
	ActivationPin *TActivationPinType `xml:"ActivationPin"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_ActivationPin function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_ActivationPin instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_ActivationPin instance.
func (me *XsdGoPkgHasElem_ActivationPin) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_ActivationPin; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.ActivationPin.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TKeyActivationType struct {
	XsdGoPkgHasElem_ActivationPin

	XsdGoPkgHasElems_Extension
}

//	If the WalkHandlers.TKeyActivationType function is not nil (ie. was set by outside code), calls it with this TKeyActivationType instance as the single argument. Then calls the Walk() method on 2/2 embed(s) and 0/0 field(s) belonging to this TKeyActivationType instance.
func (me *TKeyActivationType) Walk() (err error) {
	if fn := WalkHandlers.TKeyActivationType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElem_ActivationPin.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_KeyActivation struct {
	//	The actions that must be performed
	//	before the private key can be used.
	KeyActivation *TKeyActivationType `xml:"KeyActivation"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_KeyActivation function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_KeyActivation instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_KeyActivation instance.
func (me *XsdGoPkgHasElem_KeyActivation) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_KeyActivation; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.KeyActivation.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	In which medium is the key stored.
//	memory - the key is stored in memory.
//	smartcard - the key is stored in a smartcard.
//	token - the key is stored in a hardware token.
//	MobileDevice - the key is stored in a mobile device.
//	MobileAuthCard - the key is stored in a mobile
//	authentication card.
type TmediumType xsdt.Nmtoken

//	Since TmediumType is just a simple String type, this merely sets the current value from the specified string.
func (me *TmediumType) Set(s string) { (*xsdt.Nmtoken)(me).Set(s) }

//	Since TmediumType is just a simple String type, this merely returns the current string value.
func (me TmediumType) String() string { return xsdt.Nmtoken(me).String() }

//	This convenience method just performs a simple type conversion to TmediumType's alias type xsdt.Nmtoken.
func (me TmediumType) ToXsdtNmtoken() xsdt.Nmtoken { return xsdt.Nmtoken(me) }

//	Returns true if the value of this enumerated TmediumType is "memory".
func (me TmediumType) IsMemory() bool { return me.String() == "memory" }

//	Returns true if the value of this enumerated TmediumType is "smartcard".
func (me TmediumType) IsSmartcard() bool { return me.String() == "smartcard" }

//	Returns true if the value of this enumerated TmediumType is "token".
func (me TmediumType) IsToken() bool { return me.String() == "token" }

//	Returns true if the value of this enumerated TmediumType is "MobileDevice".
func (me TmediumType) IsMobileDevice() bool { return me.String() == "MobileDevice" }

//	Returns true if the value of this enumerated TmediumType is "MobileAuthCard".
func (me TmediumType) IsMobileAuthCard() bool { return me.String() == "MobileAuthCard" }

type XsdGoPkgHasAttr_Medium_TmediumType_ struct {
	Medium TmediumType `xml:"medium,attr"`
}

type TKeyStorageType struct {
	XsdGoPkgHasAttr_Medium_TmediumType_
}

//	If the WalkHandlers.TKeyStorageType function is not nil (ie. was set by outside code), calls it with this TKeyStorageType instance as the single argument. Then calls the Walk() method on 0/1 embed(s) and 0/0 field(s) belonging to this TKeyStorageType instance.
func (me *TKeyStorageType) Walk() (err error) {
	if fn := WalkHandlers.TKeyStorageType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_KeyStorage struct {
	//	In which medium is the key stored.
	//	memory - the key is stored in memory.
	//	smartcard - the key is stored in a smartcard.
	//	token - the key is stored in a hardware token.
	//	MobileDevice - the key is stored in a mobile device.
	//	MobileAuthCard - the key is stored in a mobile
	//	authentication card.
	KeyStorage *TKeyStorageType `xml:"KeyStorage"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_KeyStorage function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_KeyStorage instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_KeyStorage instance.
func (me *XsdGoPkgHasElem_KeyStorage) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_KeyStorage; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.KeyStorage.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TSecretKeyProtectionType struct {
	XsdGoPkgHasElem_KeyActivation

	XsdGoPkgHasElem_KeyStorage

	XsdGoPkgHasElems_Extension
}

//	If the WalkHandlers.TSecretKeyProtectionType function is not nil (ie. was set by outside code), calls it with this TSecretKeyProtectionType instance as the single argument. Then calls the Walk() method on 3/3 embed(s) and 0/0 field(s) belonging to this TSecretKeyProtectionType instance.
func (me *TSecretKeyProtectionType) Walk() (err error) {
	if fn := WalkHandlers.TSecretKeyProtectionType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElem_KeyActivation.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_KeyStorage.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_SecretKeyProtection struct {
	//	This element indicates the types and strengths of
	//	facilities
	//	of a UA used to protect a shared secret key from
	//	unauthorized access and/or use.
	SecretKeyProtection *TSecretKeyProtectionType `xml:"SecretKeyProtection"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_SecretKeyProtection function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_SecretKeyProtection instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_SecretKeyProtection instance.
func (me *XsdGoPkgHasElem_SecretKeyProtection) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_SecretKeyProtection; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.SecretKeyProtection.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates the types and strengths of
//	facilities
//	of a UA used to protect a private key from
//	unauthorized access and/or use.
//	Whether or not the private key is shared
//	with the certificate authority.
type XsdGoPkgHasAttr_Sharing_XsdtBoolean_ struct {
	Sharing xsdt.Boolean `xml:"sharing,attr"`
}

type TKeySharingType struct {
	XsdGoPkgHasAttr_Sharing_XsdtBoolean_
}

//	If the WalkHandlers.TKeySharingType function is not nil (ie. was set by outside code), calls it with this TKeySharingType instance as the single argument. Then calls the Walk() method on 0/1 embed(s) and 0/0 field(s) belonging to this TKeySharingType instance.
func (me *TKeySharingType) Walk() (err error) {
	if fn := WalkHandlers.TKeySharingType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_KeySharing struct {
	//	Whether or not the private key is shared
	//	with the certificate authority.
	KeySharing *TKeySharingType `xml:"KeySharing"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_KeySharing function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_KeySharing instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_KeySharing instance.
func (me *XsdGoPkgHasElem_KeySharing) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_KeySharing; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.KeySharing.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TPrivateKeyProtectionType struct {
	XsdGoPkgHasElem_KeyActivation

	XsdGoPkgHasElem_KeyStorage

	XsdGoPkgHasElem_KeySharing

	XsdGoPkgHasElems_Extension
}

//	If the WalkHandlers.TPrivateKeyProtectionType function is not nil (ie. was set by outside code), calls it with this TPrivateKeyProtectionType instance as the single argument. Then calls the Walk() method on 4/4 embed(s) and 0/0 field(s) belonging to this TPrivateKeyProtectionType instance.
func (me *TPrivateKeyProtectionType) Walk() (err error) {
	if fn := WalkHandlers.TPrivateKeyProtectionType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElem_KeyActivation.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_KeyStorage.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_KeySharing.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_PrivateKeyProtection struct {
	//	This element indicates the types and strengths of
	//	facilities
	//	of a UA used to protect a private key from
	//	unauthorized access and/or use.
	PrivateKeyProtection *TPrivateKeyProtectionType `xml:"PrivateKeyProtection"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_PrivateKeyProtection function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_PrivateKeyProtection instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_PrivateKeyProtection instance.
func (me *XsdGoPkgHasElem_PrivateKeyProtection) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_PrivateKeyProtection; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.PrivateKeyProtection.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TechnicalProtectionBaseType struct {
	XsdGoPkgHasElem_PrivateKeyProtection

	XsdGoPkgHasElem_SecretKeyProtection

	XsdGoPkgHasElems_Extension
}

//	If the WalkHandlers.TechnicalProtectionBaseType function is not nil (ie. was set by outside code), calls it with this TechnicalProtectionBaseType instance as the single argument. Then calls the Walk() method on 3/3 embed(s) and 0/0 field(s) belonging to this TechnicalProtectionBaseType instance.
func (me *TechnicalProtectionBaseType) Walk() (err error) {
	if fn := WalkHandlers.TechnicalProtectionBaseType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElem_PrivateKeyProtection.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_SecretKeyProtection.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_TechnicalProtection struct {
	//	Refers to those characterstics that describe how the
	//	'secret' (the knowledge or possession
	//	of which allows the Principal to authenticate to the
	//	Authentication Authority) is kept secure
	TechnicalProtection *TechnicalProtectionBaseType `xml:"TechnicalProtection"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_TechnicalProtection function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_TechnicalProtection instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_TechnicalProtection instance.
func (me *XsdGoPkgHasElem_TechnicalProtection) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_TechnicalProtection; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.TechnicalProtection.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Refers to those characteristics that describe
//	procedural security controls employed by the Authentication Authority.
type XsdGoPkgHasElem_SwitchAudit struct {
	SwitchAudit *TExtensionOnlyType `xml:"SwitchAudit"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_SwitchAudit function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_SwitchAudit instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_SwitchAudit instance.
func (me *XsdGoPkgHasElem_SwitchAudit) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_SwitchAudit; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.SwitchAudit.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TSecurityAuditType struct {
	XsdGoPkgHasElem_SwitchAudit

	XsdGoPkgHasElems_Extension
}

//	If the WalkHandlers.TSecurityAuditType function is not nil (ie. was set by outside code), calls it with this TSecurityAuditType instance as the single argument. Then calls the Walk() method on 2/2 embed(s) and 0/0 field(s) belonging to this TSecurityAuditType instance.
func (me *TSecurityAuditType) Walk() (err error) {
	if fn := WalkHandlers.TSecurityAuditType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElem_SwitchAudit.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_SecurityAudit struct {
	SecurityAudit *TSecurityAuditType `xml:"SecurityAudit"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_SecurityAudit function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_SecurityAudit instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_SecurityAudit instance.
func (me *XsdGoPkgHasElem_SecurityAudit) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_SecurityAudit; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.SecurityAudit.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_DeactivationCallCenter struct {
	DeactivationCallCenter *TExtensionOnlyType `xml:"DeactivationCallCenter"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_DeactivationCallCenter function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_DeactivationCallCenter instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_DeactivationCallCenter instance.
func (me *XsdGoPkgHasElem_DeactivationCallCenter) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_DeactivationCallCenter; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.DeactivationCallCenter.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TOperationalProtectionType struct {
	XsdGoPkgHasElem_SecurityAudit

	XsdGoPkgHasElem_DeactivationCallCenter

	XsdGoPkgHasElems_Extension
}

//	If the WalkHandlers.TOperationalProtectionType function is not nil (ie. was set by outside code), calls it with this TOperationalProtectionType instance as the single argument. Then calls the Walk() method on 3/3 embed(s) and 0/0 field(s) belonging to this TOperationalProtectionType instance.
func (me *TOperationalProtectionType) Walk() (err error) {
	if fn := WalkHandlers.TOperationalProtectionType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElems_Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_SecurityAudit.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_DeactivationCallCenter.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_OperationalProtection struct {
	//	Refers to those characteristics that describe
	//	procedural security controls employed by the Authentication Authority.
	OperationalProtection *TOperationalProtectionType `xml:"OperationalProtection"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_OperationalProtection function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_OperationalProtection instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_OperationalProtection instance.
func (me *XsdGoPkgHasElem_OperationalProtection) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_OperationalProtection; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.OperationalProtection.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Refers to those characteristics that define the
//	mechanisms by which the Principal authenticates to the Authentication
//	Authority.
//	The method that a Principal employs to perform
//	authentication to local system components.
//	This element indicates that a password (or passphrase)
//	has been used to
//	authenticate the Principal to a remote system.
type XsdGoPkgHasAttr_ExternalVerification_XsdtAnyURI_ struct {
	ExternalVerification xsdt.AnyURI `xml:"ExternalVerification,attr"`
}

type TPasswordType struct {
	XsdGoPkgHasAttr_ExternalVerification_XsdtAnyURI_

	XsdGoPkgHasElem_Length

	XsdGoPkgHasElem_Alphabet

	XsdGoPkgHasElem_Generation

	XsdGoPkgHasElems_Extension
}

//	If the WalkHandlers.TPasswordType function is not nil (ie. was set by outside code), calls it with this TPasswordType instance as the single argument. Then calls the Walk() method on 4/5 embed(s) and 0/0 field(s) belonging to this TPasswordType instance.
func (me *TPasswordType) Walk() (err error) {
	if fn := WalkHandlers.TPasswordType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElem_Alphabet.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_Generation.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_Length.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_Password struct {
	//	This element indicates that a password (or passphrase)
	//	has been used to
	//	authenticate the Principal to a remote system.
	Password *TPasswordType `xml:"Password"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_Password function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_Password instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_Password instance.
func (me *XsdGoPkgHasElem_Password) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_Password; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Password.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TxsdRestrictedLengthTypeComplexContentRestrictionMin xsdt.Integer

//	Since TxsdRestrictedLengthTypeComplexContentRestrictionMin is a non-string scalar type (either boolean or numeric), sets the current value obtained from parsing the specified string.
func (me *TxsdRestrictedLengthTypeComplexContentRestrictionMin) Set(s string) {
	(*xsdt.Integer)(me).Set(s)
}

//	Returns a string representation of this TxsdRestrictedLengthTypeComplexContentRestrictionMin's current non-string scalar value.
func (me TxsdRestrictedLengthTypeComplexContentRestrictionMin) String() string {
	return xsdt.Integer(me).String()
}

//	This convenience method just performs a simple type conversion to TxsdRestrictedLengthTypeComplexContentRestrictionMin's alias type xsdt.Integer.
func (me TxsdRestrictedLengthTypeComplexContentRestrictionMin) ToXsdtInteger() xsdt.Integer {
	return xsdt.Integer(me)
}

type XsdGoPkgHasAttr_Min_TxsdRestrictedLengthTypeComplexContentRestrictionMin_ struct {
	Min TxsdRestrictedLengthTypeComplexContentRestrictionMin `xml:"min,attr"`
}

type TRestrictedLengthType struct {
	XsdGoPkgHasAttr_Max_XsdtInteger_

	TLengthType

	XsdGoPkgHasAttr_Min_TxsdRestrictedLengthTypeComplexContentRestrictionMin_
}

//	If the WalkHandlers.TRestrictedLengthType function is not nil (ie. was set by outside code), calls it with this TRestrictedLengthType instance as the single argument. Then calls the Walk() method on 1/3 embed(s) and 0/0 field(s) belonging to this TRestrictedLengthType instance.
func (me *TRestrictedLengthType) Walk() (err error) {
	if fn := WalkHandlers.TRestrictedLengthType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.TLengthType.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschema_Length_TRestrictedLengthType_ struct {
	Length *TRestrictedLengthType `xml:"Length"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschema_Length_TRestrictedLengthType_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschema_Length_TRestrictedLengthType_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschema_Length_TRestrictedLengthType_ instance.
func (me *XsdGoPkgHasElem_LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschema_Length_TRestrictedLengthType_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschema_Length_TRestrictedLengthType_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Length.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TRestrictedPasswordType struct {
	TPasswordType

	XsdGoPkgHasElem_LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschema_Length_TRestrictedLengthType_

	XsdGoPkgHasElem_Generation

	XsdGoPkgHasElems_Extension

	XsdGoPkgHasAttr_ExternalVerification_XsdtAnyURI_
}

//	If the WalkHandlers.TRestrictedPasswordType function is not nil (ie. was set by outside code), calls it with this TRestrictedPasswordType instance as the single argument. Then calls the Walk() method on 4/5 embed(s) and 0/0 field(s) belonging to this TRestrictedPasswordType instance.
func (me *TRestrictedPasswordType) Walk() (err error) {
	if fn := WalkHandlers.TRestrictedPasswordType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.TPasswordType.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschema_Length_TRestrictedLengthType_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_Generation.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_RestrictedPassword struct {
	RestrictedPassword *TRestrictedPasswordType `xml:"RestrictedPassword"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_RestrictedPassword function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_RestrictedPassword instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_RestrictedPassword instance.
func (me *XsdGoPkgHasElem_RestrictedPassword) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_RestrictedPassword; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.RestrictedPassword.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that a hardware or software
//	token is used
//	as a method of identifying the Principal.
//	This element indicates that a time synchronization
//	token is used to identify the Principal. hardware -
//	the time synchonization
//	token has been implemented in hardware. software - the
//	time synchronization
//	token has been implemented in software. SeedLength -
//	the length, in bits, of the
//	random seed used in the time synchronization token.
type TDeviceTypeType xsdt.Nmtoken

//	This convenience method just performs a simple type conversion to TDeviceTypeType's alias type xsdt.Nmtoken.
func (me TDeviceTypeType) ToXsdtNmtoken() xsdt.Nmtoken { return xsdt.Nmtoken(me) }

//	Returns true if the value of this enumerated TDeviceTypeType is "hardware".
func (me TDeviceTypeType) IsHardware() bool { return me.String() == "hardware" }

//	Returns true if the value of this enumerated TDeviceTypeType is "software".
func (me TDeviceTypeType) IsSoftware() bool { return me.String() == "software" }

//	Since TDeviceTypeType is just a simple String type, this merely sets the current value from the specified string.
func (me *TDeviceTypeType) Set(s string) { (*xsdt.Nmtoken)(me).Set(s) }

//	Since TDeviceTypeType is just a simple String type, this merely returns the current string value.
func (me TDeviceTypeType) String() string { return xsdt.Nmtoken(me).String() }

type XsdGoPkgHasAttr_DeviceType_TDeviceTypeType_ struct {
	DeviceType TDeviceTypeType `xml:"DeviceType,attr"`
}

type XsdGoPkgHasAttr_SeedLength_XsdtInteger_ struct {
	SeedLength xsdt.Integer `xml:"SeedLength,attr"`
}

type TbooleanType xsdt.Nmtoken

//	Since TbooleanType is just a simple String type, this merely sets the current value from the specified string.
func (me *TbooleanType) Set(s string) { (*xsdt.Nmtoken)(me).Set(s) }

//	Since TbooleanType is just a simple String type, this merely returns the current string value.
func (me TbooleanType) String() string { return xsdt.Nmtoken(me).String() }

//	This convenience method just performs a simple type conversion to TbooleanType's alias type xsdt.Nmtoken.
func (me TbooleanType) ToXsdtNmtoken() xsdt.Nmtoken { return xsdt.Nmtoken(me) }

//	Returns true if the value of this enumerated TbooleanType is "true".
func (me TbooleanType) IsTrue() bool { return me.String() == "true" }

//	Returns true if the value of this enumerated TbooleanType is "false".
func (me TbooleanType) IsFalse() bool { return me.String() == "false" }

type XsdGoPkgHasAttr_DeviceInHand_TbooleanType_ struct {
	DeviceInHand TbooleanType `xml:"DeviceInHand,attr"`
}

type TimeSyncTokenType struct {
	XsdGoPkgHasAttr_DeviceInHand_TbooleanType_

	XsdGoPkgHasAttr_DeviceType_TDeviceTypeType_

	XsdGoPkgHasAttr_SeedLength_XsdtInteger_
}

//	If the WalkHandlers.TimeSyncTokenType function is not nil (ie. was set by outside code), calls it with this TimeSyncTokenType instance as the single argument. Then calls the Walk() method on 0/3 embed(s) and 0/0 field(s) belonging to this TimeSyncTokenType instance.
func (me *TimeSyncTokenType) Walk() (err error) {
	if fn := WalkHandlers.TimeSyncTokenType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_TimeSyncToken struct {
	//	This element indicates that a time synchronization
	//	token is used to identify the Principal. hardware -
	//	the time synchonization
	//	token has been implemented in hardware. software - the
	//	time synchronization
	//	token has been implemented in software. SeedLength -
	//	the length, in bits, of the
	//	random seed used in the time synchronization token.
	TimeSyncToken *TimeSyncTokenType `xml:"TimeSyncToken"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_TimeSyncToken function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_TimeSyncToken instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_TimeSyncToken instance.
func (me *XsdGoPkgHasElem_TimeSyncToken) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_TimeSyncToken; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.TimeSyncToken.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TokenType struct {
	XsdGoPkgHasElem_TimeSyncToken

	XsdGoPkgHasElems_Extension
}

//	If the WalkHandlers.TokenType function is not nil (ie. was set by outside code), calls it with this TokenType instance as the single argument. Then calls the Walk() method on 2/2 embed(s) and 0/0 field(s) belonging to this TokenType instance.
func (me *TokenType) Walk() (err error) {
	if fn := WalkHandlers.TokenType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElem_TimeSyncToken.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_Token struct {
	//	This element indicates that a hardware or software
	//	token is used
	//	as a method of identifying the Principal.
	Token *TokenType `xml:"Token"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_Token function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_Token instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_Token instance.
func (me *XsdGoPkgHasElem_Token) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_Token; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Token.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that a smartcard is used to
//	identity the Principal.
type XsdGoPkgHasElem_Smartcard struct {
	//	This element indicates that a smartcard is used to
	//	identity the Principal.
	Smartcard *TExtensionOnlyType `xml:"Smartcard"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_Smartcard function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_Smartcard instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_Smartcard instance.
func (me *XsdGoPkgHasElem_Smartcard) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_Smartcard; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Smartcard.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasAttr_Preauth_XsdtInteger_ struct {
	Preauth xsdt.Integer `xml:"preauth,attr"`
}

type TPrincipalAuthenticationMechanismType struct {
	XsdGoPkgHasElem_Smartcard

	XsdGoPkgHasElem_ActivationPin

	XsdGoPkgHasElems_Extension

	XsdGoPkgHasAttr_Preauth_XsdtInteger_

	XsdGoPkgHasElem_Password

	XsdGoPkgHasElem_RestrictedPassword

	XsdGoPkgHasElem_Token
}

//	If the WalkHandlers.TPrincipalAuthenticationMechanismType function is not nil (ie. was set by outside code), calls it with this TPrincipalAuthenticationMechanismType instance as the single argument. Then calls the Walk() method on 6/7 embed(s) and 0/0 field(s) belonging to this TPrincipalAuthenticationMechanismType instance.
func (me *TPrincipalAuthenticationMechanismType) Walk() (err error) {
	if fn := WalkHandlers.TPrincipalAuthenticationMechanismType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElem_Password.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_RestrictedPassword.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_Token.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_Smartcard.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_ActivationPin.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_PrincipalAuthenticationMechanism struct {
	//	The method that a Principal employs to perform
	//	authentication to local system components.
	PrincipalAuthenticationMechanism *TPrincipalAuthenticationMechanismType `xml:"PrincipalAuthenticationMechanism"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_PrincipalAuthenticationMechanism function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_PrincipalAuthenticationMechanism instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_PrincipalAuthenticationMechanism instance.
func (me *XsdGoPkgHasElem_PrincipalAuthenticationMechanism) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_PrincipalAuthenticationMechanism; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.PrincipalAuthenticationMechanism.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The method applied to validate a principal's
//	authentication across a network
//	The local system has a private key but it is used
//	in decryption mode, rather than signature mode. For example, the
//	Authentication Authority generates a secret and encrypts it using the
//	local system's public key: the local system then proves it has
//	decrypted the secret.
type XsdGoPkgHasAttr_KeyValidation_XsdtString_ struct {
	KeyValidation xsdt.String `xml:"keyValidation,attr"`
}

type TPublicKeyType struct {
	XsdGoPkgHasElems_Extension

	XsdGoPkgHasAttr_KeyValidation_XsdtString_
}

//	If the WalkHandlers.TPublicKeyType function is not nil (ie. was set by outside code), calls it with this TPublicKeyType instance as the single argument. Then calls the Walk() method on 1/2 embed(s) and 0/0 field(s) belonging to this TPublicKeyType instance.
func (me *TPublicKeyType) Walk() (err error) {
	if fn := WalkHandlers.TPublicKeyType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElems_Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_AsymmetricDecryption struct {
	//	The local system has a private key but it is used
	//	in decryption mode, rather than signature mode. For example, the
	//	Authentication Authority generates a secret and encrypts it using the
	//	local system's public key: the local system then proves it has
	//	decrypted the secret.
	AsymmetricDecryption *TPublicKeyType `xml:"AsymmetricDecryption"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_AsymmetricDecryption function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_AsymmetricDecryption instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_AsymmetricDecryption instance.
func (me *XsdGoPkgHasElem_AsymmetricDecryption) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_AsymmetricDecryption; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.AsymmetricDecryption.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_SubscriberLineNumber struct {
	SubscriberLineNumber *TExtensionOnlyType `xml:"SubscriberLineNumber"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_SubscriberLineNumber function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_SubscriberLineNumber instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_SubscriberLineNumber instance.
func (me *XsdGoPkgHasElem_SubscriberLineNumber) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_SubscriberLineNumber; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.SubscriberLineNumber.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Supports Authenticators with nested combinations of
//	additional complexity.
//	Rather like PreviousSession but using stronger
//	security. A secret that was established in a previous session with
//	the Authentication Authority has been cached by the local system and
//	is now re-used (e.g. a Master Secret is used to derive new session
//	keys in TLS, SSL, WTLS).
type XsdGoPkgHasElem_ResumeSession struct {
	//	Rather like PreviousSession but using stronger
	//	security. A secret that was established in a previous session with
	//	the Authentication Authority has been cached by the local system and
	//	is now re-used (e.g. a Master Secret is used to derive new session
	//	keys in TLS, SSL, WTLS).
	ResumeSession *TExtensionOnlyType `xml:"ResumeSession"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_ResumeSession function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_ResumeSession instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_ResumeSession instance.
func (me *XsdGoPkgHasElem_ResumeSession) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_ResumeSession; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.ResumeSession.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Principal has been
//	authenticated by a challenge-response protocol utilizing shared secret
//	keys and symmetric cryptography.
type XsdGoPkgHasAttr_Method_XsdtAnyURI_ struct {
	Method xsdt.AnyURI `xml:"method,attr"`
}

type TSharedSecretChallengeResponseType struct {
	XsdGoPkgHasElems_Extension

	XsdGoPkgHasAttr_Method_XsdtAnyURI_
}

//	If the WalkHandlers.TSharedSecretChallengeResponseType function is not nil (ie. was set by outside code), calls it with this TSharedSecretChallengeResponseType instance as the single argument. Then calls the Walk() method on 1/2 embed(s) and 0/0 field(s) belonging to this TSharedSecretChallengeResponseType instance.
func (me *TSharedSecretChallengeResponseType) Walk() (err error) {
	if fn := WalkHandlers.TSharedSecretChallengeResponseType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElems_Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_SharedSecretChallengeResponse struct {
	SharedSecretChallengeResponse *TSharedSecretChallengeResponseType `xml:"SharedSecretChallengeResponse"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_SharedSecretChallengeResponse function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_SharedSecretChallengeResponse instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_SharedSecretChallengeResponse instance.
func (me *XsdGoPkgHasElem_SharedSecretChallengeResponse) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_SharedSecretChallengeResponse; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.SharedSecretChallengeResponse.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Principal has been
//	authenticated through connection from a particular IP address.
type XsdGoPkgHasElem_IPAddress struct {
	//	This element indicates that the Principal has been
	//	authenticated through connection from a particular IP address.
	IPAddress *TExtensionOnlyType `xml:"IPAddress"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_IPAddress function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_IPAddress instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_IPAddress instance.
func (me *XsdGoPkgHasElem_IPAddress) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_IPAddress; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.IPAddress.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The local system has a private key and uses it for
//	shared secret key agreement with the Authentication Authority (e.g.
//	via Diffie Helman).
type XsdGoPkgHasElem_AsymmetricKeyAgreement struct {
	//	The local system has a private key and uses it for
	//	shared secret key agreement with the Authentication Authority (e.g.
	//	via Diffie Helman).
	AsymmetricKeyAgreement *TPublicKeyType `xml:"AsymmetricKeyAgreement"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_AsymmetricKeyAgreement function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_AsymmetricKeyAgreement instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_AsymmetricKeyAgreement instance.
func (me *XsdGoPkgHasElem_AsymmetricKeyAgreement) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_AsymmetricKeyAgreement; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.AsymmetricKeyAgreement.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Indicates that the Principal has been strongly
//	authenticated in a previous session during which the IdP has set a
//	cookie in the UA. During the present session the Principal has only
//	been authenticated by the UA returning the cookie to the IdP.
type XsdGoPkgHasElem_PreviousSession struct {
	//	Indicates that the Principal has been strongly
	//	authenticated in a previous session during which the IdP has set a
	//	cookie in the UA. During the present session the Principal has only
	//	been authenticated by the UA returning the cookie to the IdP.
	PreviousSession *TExtensionOnlyType `xml:"PreviousSession"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_PreviousSession function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_PreviousSession instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_PreviousSession instance.
func (me *XsdGoPkgHasElem_PreviousSession) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_PreviousSession; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.PreviousSession.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The local system and Authentication Authority
//	share a secret key. The local system uses this to encrypt a
//	randomised string to pass to the Authentication Authority.
type XsdGoPkgHasElem_SharedSecretDynamicPlaintext struct {
	//	The local system and Authentication Authority
	//	share a secret key. The local system uses this to encrypt a
	//	randomised string to pass to the Authentication Authority.
	SharedSecretDynamicPlaintext *TExtensionOnlyType `xml:"SharedSecretDynamicPlaintext"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_SharedSecretDynamicPlaintext function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_SharedSecretDynamicPlaintext instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_SharedSecretDynamicPlaintext instance.
func (me *XsdGoPkgHasElem_SharedSecretDynamicPlaintext) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_SharedSecretDynamicPlaintext; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.SharedSecretDynamicPlaintext.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_UserSuffix struct {
	UserSuffix *TExtensionOnlyType `xml:"UserSuffix"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_UserSuffix function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_UserSuffix instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_UserSuffix instance.
func (me *XsdGoPkgHasElem_UserSuffix) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_UserSuffix; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.UserSuffix.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Principal has been
//	authenticated by a mechanism which involves the Principal computing a
//	digital signature over at least challenge data provided by the IdP.
type XsdGoPkgHasElem_DigSig struct {
	//	This element indicates that the Principal has been
	//	authenticated by a mechanism which involves the Principal computing a
	//	digital signature over at least challenge data provided by the IdP.
	DigSig *TPublicKeyType `xml:"DigSig"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_DigSig function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_DigSig instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_DigSig instance.
func (me *XsdGoPkgHasElem_DigSig) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_DigSig; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.DigSig.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Principal has been
//	authenticated by a zero knowledge technique as specified in ISO/IEC
//	9798-5.
type XsdGoPkgHasElem_ZeroKnowledge struct {
	//	This element indicates that the Principal has been
	//	authenticated by a zero knowledge technique as specified in ISO/IEC
	//	9798-5.
	ZeroKnowledge *TExtensionOnlyType `xml:"ZeroKnowledge"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_ZeroKnowledge function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_ZeroKnowledge instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_ZeroKnowledge instance.
func (me *XsdGoPkgHasElem_ZeroKnowledge) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_ZeroKnowledge; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.ZeroKnowledge.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasGroup_AuthenticatorSequenceGroup struct {
	XsdGoPkgHasElem_PreviousSession

	XsdGoPkgHasElem_RestrictedPassword

	XsdGoPkgHasElem_SharedSecretDynamicPlaintext

	XsdGoPkgHasElem_UserSuffix

	XsdGoPkgHasElem_DigSig

	XsdGoPkgHasElem_ZeroKnowledge

	XsdGoPkgHasElems_Extension

	XsdGoPkgHasElem_SubscriberLineNumber

	XsdGoPkgHasElem_ResumeSession

	XsdGoPkgHasElem_Password

	XsdGoPkgHasElem_SharedSecretChallengeResponse

	XsdGoPkgHasElem_IPAddress

	XsdGoPkgHasElem_AsymmetricDecryption

	XsdGoPkgHasElem_AsymmetricKeyAgreement
}

//	If the WalkHandlers.XsdGoPkgHasGroup_AuthenticatorSequenceGroup function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasGroup_AuthenticatorSequenceGroup instance as the single argument. Then calls the Walk() method on 14/14 embed(s) and 0/0 field(s) belonging to this XsdGoPkgHasGroup_AuthenticatorSequenceGroup instance.
func (me *XsdGoPkgHasGroup_AuthenticatorSequenceGroup) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasGroup_AuthenticatorSequenceGroup; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElem_AsymmetricDecryption.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_AsymmetricKeyAgreement.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_PreviousSession.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_RestrictedPassword.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_SharedSecretDynamicPlaintext.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_UserSuffix.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_DigSig.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_ZeroKnowledge.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_ResumeSession.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_Password.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_SharedSecretChallengeResponse.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_IPAddress.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_SubscriberLineNumber.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TComplexAuthenticatorType struct {
	XsdGoPkgHasGroup_AuthenticatorChoiceGroup

	XsdGoPkgHasGroup_AuthenticatorSequenceGroup
}

//	If the WalkHandlers.TComplexAuthenticatorType function is not nil (ie. was set by outside code), calls it with this TComplexAuthenticatorType instance as the single argument. Then calls the Walk() method on 1/2 embed(s) and 0/0 field(s) belonging to this TComplexAuthenticatorType instance.
func (me *TComplexAuthenticatorType) Walk() (err error) {
	if fn := WalkHandlers.TComplexAuthenticatorType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasGroup_AuthenticatorSequenceGroup.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_ComplexAuthenticator struct {
	//	Supports Authenticators with nested combinations of
	//	additional complexity.
	ComplexAuthenticator *TComplexAuthenticatorType `xml:"ComplexAuthenticator"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_ComplexAuthenticator function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_ComplexAuthenticator instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_ComplexAuthenticator instance.
func (me *XsdGoPkgHasElem_ComplexAuthenticator) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_ComplexAuthenticator; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.ComplexAuthenticator.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasGroup_AuthenticatorChoiceGroup struct {
	XsdGoPkgHasElem_ZeroKnowledge

	XsdGoPkgHasElem_SharedSecretChallengeResponse

	XsdGoPkgHasElem_IPAddress

	XsdGoPkgHasElem_AsymmetricKeyAgreement

	XsdGoPkgHasElem_UserSuffix

	XsdGoPkgHasElem_DigSig

	XsdGoPkgHasElem_ResumeSession

	XsdGoPkgHasElem_AsymmetricDecryption

	XsdGoPkgHasElem_SubscriberLineNumber

	XsdGoPkgHasElem_ComplexAuthenticator

	XsdGoPkgHasElem_PreviousSession

	XsdGoPkgHasElem_RestrictedPassword

	XsdGoPkgHasElem_SharedSecretDynamicPlaintext

	XsdGoPkgHasElem_Password
}

//	If the WalkHandlers.XsdGoPkgHasGroup_AuthenticatorChoiceGroup function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasGroup_AuthenticatorChoiceGroup instance as the single argument. Then calls the Walk() method on 14/14 embed(s) and 0/0 field(s) belonging to this XsdGoPkgHasGroup_AuthenticatorChoiceGroup instance.
func (me *XsdGoPkgHasGroup_AuthenticatorChoiceGroup) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasGroup_AuthenticatorChoiceGroup; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElem_ComplexAuthenticator.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_PreviousSession.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_ResumeSession.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_AsymmetricDecryption.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_SubscriberLineNumber.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_Password.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_RestrictedPassword.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_SharedSecretDynamicPlaintext.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_AsymmetricKeyAgreement.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_UserSuffix.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_DigSig.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_ZeroKnowledge.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_SharedSecretChallengeResponse.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_IPAddress.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TAuthenticatorBaseType struct {
	XsdGoPkgHasGroup_AuthenticatorSequenceGroup

	XsdGoPkgHasGroup_AuthenticatorChoiceGroup
}

//	If the WalkHandlers.TAuthenticatorBaseType function is not nil (ie. was set by outside code), calls it with this TAuthenticatorBaseType instance as the single argument. Then calls the Walk() method on 2/2 embed(s) and 0/0 field(s) belonging to this TAuthenticatorBaseType instance.
func (me *TAuthenticatorBaseType) Walk() (err error) {
	if fn := WalkHandlers.TAuthenticatorBaseType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasGroup_AuthenticatorChoiceGroup.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasGroup_AuthenticatorSequenceGroup.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_Authenticator struct {
	//	The method applied to validate a principal's
	//	authentication across a network
	Authenticator *TAuthenticatorBaseType `xml:"Authenticator"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_Authenticator function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_Authenticator instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_Authenticator instance.
func (me *XsdGoPkgHasElem_Authenticator) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_Authenticator; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Authenticator.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The protocol across which Authenticator information is
//	transferred to an Authentication Authority verifier.
//	This element indicates that the Authenticator has been
//	transmitted using a transport mechnanism protected by an SSL or TLS
//	session.
type XsdGoPkgHasElem_Ssl struct {
	//	This element indicates that the Authenticator has been
	//	transmitted using a transport mechnanism protected by an SSL or TLS
	//	session.
	Ssl *TExtensionOnlyType `xml:"SSL"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_Ssl function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_Ssl instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_Ssl instance.
func (me *XsdGoPkgHasElem_Ssl) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_Ssl; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Ssl.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_MobileNetworkRadioEncryption struct {
	MobileNetworkRadioEncryption *TExtensionOnlyType `xml:"MobileNetworkRadioEncryption"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_MobileNetworkRadioEncryption function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_MobileNetworkRadioEncryption instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_MobileNetworkRadioEncryption instance.
func (me *XsdGoPkgHasElem_MobileNetworkRadioEncryption) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_MobileNetworkRadioEncryption; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.MobileNetworkRadioEncryption.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_MobileNetworkEndToEndEncryption struct {
	MobileNetworkEndToEndEncryption *TExtensionOnlyType `xml:"MobileNetworkEndToEndEncryption"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_MobileNetworkEndToEndEncryption function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_MobileNetworkEndToEndEncryption instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_MobileNetworkEndToEndEncryption instance.
func (me *XsdGoPkgHasElem_MobileNetworkEndToEndEncryption) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_MobileNetworkEndToEndEncryption; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.MobileNetworkEndToEndEncryption.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Authenticator has been
//	transmitted using a transport mechanism protected by an IPSEC session.
type XsdGoPkgHasElem_IPSec struct {
	//	This element indicates that the Authenticator has been
	//	transmitted using a transport mechanism protected by an IPSEC session.
	IPSec *TExtensionOnlyType `xml:"IPSec"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_IPSec function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_IPSec instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_IPSec instance.
func (me *XsdGoPkgHasElem_IPSec) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_IPSec; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.IPSec.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_Pstn struct {
	Pstn *TExtensionOnlyType `xml:"PSTN"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_Pstn function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_Pstn instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_Pstn instance.
func (me *XsdGoPkgHasElem_Pstn) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_Pstn; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Pstn.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Authenticator has been
//	transmitted using bare HTTP utilizing no additional security
//	protocols.
type XsdGoPkgHasElem_Http struct {
	//	This element indicates that the Authenticator has been
	//	transmitted using bare HTTP utilizing no additional security
	//	protocols.
	Http *TExtensionOnlyType `xml:"HTTP"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_Http function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_Http instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_Http instance.
func (me *XsdGoPkgHasElem_Http) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_Http; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Http.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Authenticator has been
//	transmitted solely across a mobile network using no additional
//	security mechanism.
type XsdGoPkgHasElem_MobileNetworkNoEncryption struct {
	//	This element indicates that the Authenticator has been
	//	transmitted solely across a mobile network using no additional
	//	security mechanism.
	MobileNetworkNoEncryption *TExtensionOnlyType `xml:"MobileNetworkNoEncryption"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_MobileNetworkNoEncryption function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_MobileNetworkNoEncryption instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_MobileNetworkNoEncryption instance.
func (me *XsdGoPkgHasElem_MobileNetworkNoEncryption) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_MobileNetworkNoEncryption; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.MobileNetworkNoEncryption.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Authenticator has been
//	transmitted using a transport mechanism protected by a WTLS session.
type XsdGoPkgHasElem_Wtls struct {
	//	This element indicates that the Authenticator has been
	//	transmitted using a transport mechanism protected by a WTLS session.
	Wtls *TExtensionOnlyType `xml:"WTLS"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_Wtls function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_Wtls instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_Wtls instance.
func (me *XsdGoPkgHasElem_Wtls) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_Wtls; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Wtls.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_Isdn struct {
	Isdn *TExtensionOnlyType `xml:"ISDN"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_Isdn function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_Isdn instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_Isdn instance.
func (me *XsdGoPkgHasElem_Isdn) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_Isdn; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Isdn.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_Adsl struct {
	Adsl *TExtensionOnlyType `xml:"ADSL"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_Adsl function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_Adsl instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_Adsl instance.
func (me *XsdGoPkgHasElem_Adsl) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_Adsl; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Adsl.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TAuthenticatorTransportProtocolType struct {
	XsdGoPkgHasElem_Ssl

	XsdGoPkgHasElem_MobileNetworkRadioEncryption

	XsdGoPkgHasElem_MobileNetworkEndToEndEncryption

	XsdGoPkgHasElem_IPSec

	XsdGoPkgHasElem_Pstn

	XsdGoPkgHasElem_Http

	XsdGoPkgHasElem_MobileNetworkNoEncryption

	XsdGoPkgHasElem_Wtls

	XsdGoPkgHasElem_Isdn

	XsdGoPkgHasElem_Adsl

	XsdGoPkgHasElems_Extension
}

//	If the WalkHandlers.TAuthenticatorTransportProtocolType function is not nil (ie. was set by outside code), calls it with this TAuthenticatorTransportProtocolType instance as the single argument. Then calls the Walk() method on 11/11 embed(s) and 0/0 field(s) belonging to this TAuthenticatorTransportProtocolType instance.
func (me *TAuthenticatorTransportProtocolType) Walk() (err error) {
	if fn := WalkHandlers.TAuthenticatorTransportProtocolType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElem_MobileNetworkEndToEndEncryption.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_IPSec.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_Pstn.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_Ssl.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_MobileNetworkRadioEncryption.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_Wtls.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_Isdn.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_Adsl.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_Http.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_MobileNetworkNoEncryption.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_AuthenticatorTransportProtocol struct {
	//	The protocol across which Authenticator information is
	//	transferred to an Authentication Authority verifier.
	AuthenticatorTransportProtocol *TAuthenticatorTransportProtocolType `xml:"AuthenticatorTransportProtocol"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_AuthenticatorTransportProtocol function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_AuthenticatorTransportProtocol instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_AuthenticatorTransportProtocol instance.
func (me *XsdGoPkgHasElem_AuthenticatorTransportProtocol) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_AuthenticatorTransportProtocol; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.AuthenticatorTransportProtocol.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TAuthnMethodBaseType struct {
	XsdGoPkgHasElem_PrincipalAuthenticationMechanism

	XsdGoPkgHasElem_Authenticator

	XsdGoPkgHasElem_AuthenticatorTransportProtocol

	XsdGoPkgHasElems_Extension
}

//	If the WalkHandlers.TAuthnMethodBaseType function is not nil (ie. was set by outside code), calls it with this TAuthnMethodBaseType instance as the single argument. Then calls the Walk() method on 4/4 embed(s) and 0/0 field(s) belonging to this TAuthnMethodBaseType instance.
func (me *TAuthnMethodBaseType) Walk() (err error) {
	if fn := WalkHandlers.TAuthnMethodBaseType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElem_PrincipalAuthenticationMechanism.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_Authenticator.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_AuthenticatorTransportProtocol.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_AuthnMethod struct {
	//	Refers to those characteristics that define the
	//	mechanisms by which the Principal authenticates to the Authentication
	//	Authority.
	AuthnMethod *TAuthnMethodBaseType `xml:"AuthnMethod"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_AuthnMethod function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_AuthnMethod instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_AuthnMethod instance.
func (me *XsdGoPkgHasElem_AuthnMethod) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_AuthnMethod; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.AuthnMethod.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TAuthnContextDeclarationBaseType struct {
	XsdGoPkgHasElem_Identification

	XsdGoPkgHasElem_TechnicalProtection

	XsdGoPkgHasElem_OperationalProtection

	XsdGoPkgHasElem_AuthnMethod

	XsdGoPkgHasElem_GoverningAgreements

	XsdGoPkgHasElems_Extension

	XsdGoPkgHasAttr_Id_XsdtId_
}

//	If the WalkHandlers.TAuthnContextDeclarationBaseType function is not nil (ie. was set by outside code), calls it with this TAuthnContextDeclarationBaseType instance as the single argument. Then calls the Walk() method on 6/7 embed(s) and 0/0 field(s) belonging to this TAuthnContextDeclarationBaseType instance.
func (me *TAuthnContextDeclarationBaseType) Walk() (err error) {
	if fn := WalkHandlers.TAuthnContextDeclarationBaseType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElems_Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_Identification.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_TechnicalProtection.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_OperationalProtection.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_AuthnMethod.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_GoverningAgreements.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_AuthenticationContextDeclaration struct {
	//	A particular assertion on an identity
	//	provider's part with respect to the authentication
	//	context associated with an authentication assertion.
	AuthenticationContextDeclaration *TAuthnContextDeclarationBaseType `xml:"AuthenticationContextDeclaration"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_AuthenticationContextDeclaration function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_AuthenticationContextDeclaration instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_AuthenticationContextDeclaration instance.
func (me *XsdGoPkgHasElem_AuthenticationContextDeclaration) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_AuthenticationContextDeclaration; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.AuthenticationContextDeclaration.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	A particular assertion on an identity
//	provider's part with respect to the authentication
//	context associated with an authentication assertion.
type XsdGoPkgHasElems_AuthenticationContextDeclaration struct {
	//	A particular assertion on an identity
	//	provider's part with respect to the authentication
	//	context associated with an authentication assertion.
	AuthenticationContextDeclarations []*TAuthnContextDeclarationBaseType `xml:"AuthenticationContextDeclaration"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_AuthenticationContextDeclaration function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_AuthenticationContextDeclaration instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_AuthenticationContextDeclaration instance.
func (me *XsdGoPkgHasElems_AuthenticationContextDeclaration) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_AuthenticationContextDeclaration; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.AuthenticationContextDeclarations {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Refers to those characteristics that describe the
//	processes and mechanisms
//	the Authentication Authority uses to initially create
//	an association between a Principal
//	and the identity (or name) by which the Principal will
//	be known
type XsdGoPkgHasElems_Identification struct {
	//	Refers to those characteristics that describe the
	//	processes and mechanisms
	//	the Authentication Authority uses to initially create
	//	an association between a Principal
	//	and the identity (or name) by which the Principal will
	//	be known
	Identifications []*TIdentificationType `xml:"Identification"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_Identification function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_Identification instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_Identification instance.
func (me *XsdGoPkgHasElems_Identification) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_Identification; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Identifications {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that identification has been
//	performed in a physical
//	face-to-face meeting with the principal and not in an
//	online manner.
type XsdGoPkgHasElems_PhysicalVerification struct {
	//	This element indicates that identification has been
	//	performed in a physical
	//	face-to-face meeting with the principal and not in an
	//	online manner.
	PhysicalVerifications []*TxsdPhysicalVerification `xml:"PhysicalVerification"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_PhysicalVerification function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_PhysicalVerification instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_PhysicalVerification instance.
func (me *XsdGoPkgHasElems_PhysicalVerification) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_PhysicalVerification; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.PhysicalVerifications {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_WrittenConsent struct {
	WrittenConsents []*TExtensionOnlyType `xml:"WrittenConsent"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_WrittenConsent function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_WrittenConsent instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_WrittenConsent instance.
func (me *XsdGoPkgHasElems_WrittenConsent) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_WrittenConsent; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.WrittenConsents {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Refers to those characterstics that describe how the
//	'secret' (the knowledge or possession
//	of which allows the Principal to authenticate to the
//	Authentication Authority) is kept secure
type XsdGoPkgHasElems_TechnicalProtection struct {
	//	Refers to those characterstics that describe how the
	//	'secret' (the knowledge or possession
	//	of which allows the Principal to authenticate to the
	//	Authentication Authority) is kept secure
	TechnicalProtections []*TechnicalProtectionBaseType `xml:"TechnicalProtection"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_TechnicalProtection function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_TechnicalProtection instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_TechnicalProtection instance.
func (me *XsdGoPkgHasElems_TechnicalProtection) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_TechnicalProtection; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.TechnicalProtections {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates the types and strengths of
//	facilities
//	of a UA used to protect a shared secret key from
//	unauthorized access and/or use.
type XsdGoPkgHasElems_SecretKeyProtection struct {
	//	This element indicates the types and strengths of
	//	facilities
	//	of a UA used to protect a shared secret key from
	//	unauthorized access and/or use.
	SecretKeyProtections []*TSecretKeyProtectionType `xml:"SecretKeyProtection"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_SecretKeyProtection function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_SecretKeyProtection instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_SecretKeyProtection instance.
func (me *XsdGoPkgHasElems_SecretKeyProtection) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_SecretKeyProtection; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.SecretKeyProtections {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates the types and strengths of
//	facilities
//	of a UA used to protect a private key from
//	unauthorized access and/or use.
type XsdGoPkgHasElems_PrivateKeyProtection struct {
	//	This element indicates the types and strengths of
	//	facilities
	//	of a UA used to protect a private key from
	//	unauthorized access and/or use.
	PrivateKeyProtections []*TPrivateKeyProtectionType `xml:"PrivateKeyProtection"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_PrivateKeyProtection function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_PrivateKeyProtection instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_PrivateKeyProtection instance.
func (me *XsdGoPkgHasElems_PrivateKeyProtection) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_PrivateKeyProtection; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.PrivateKeyProtections {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The actions that must be performed
//	before the private key can be used.
type XsdGoPkgHasElems_KeyActivation struct {
	//	The actions that must be performed
	//	before the private key can be used.
	KeyActivations []*TKeyActivationType `xml:"KeyActivation"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_KeyActivation function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_KeyActivation instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_KeyActivation instance.
func (me *XsdGoPkgHasElems_KeyActivation) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_KeyActivation; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.KeyActivations {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Whether or not the private key is shared
//	with the certificate authority.
type XsdGoPkgHasElems_KeySharing struct {
	//	Whether or not the private key is shared
	//	with the certificate authority.
	KeySharings []*TKeySharingType `xml:"KeySharing"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_KeySharing function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_KeySharing instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_KeySharing instance.
func (me *XsdGoPkgHasElems_KeySharing) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_KeySharing; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.KeySharings {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	In which medium is the key stored.
//	memory - the key is stored in memory.
//	smartcard - the key is stored in a smartcard.
//	token - the key is stored in a hardware token.
//	MobileDevice - the key is stored in a mobile device.
//	MobileAuthCard - the key is stored in a mobile
//	authentication card.
type XsdGoPkgHasElems_KeyStorage struct {
	//	In which medium is the key stored.
	//	memory - the key is stored in memory.
	//	smartcard - the key is stored in a smartcard.
	//	token - the key is stored in a hardware token.
	//	MobileDevice - the key is stored in a mobile device.
	//	MobileAuthCard - the key is stored in a mobile
	//	authentication card.
	KeyStorages []*TKeyStorageType `xml:"KeyStorage"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_KeyStorage function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_KeyStorage instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_KeyStorage instance.
func (me *XsdGoPkgHasElems_KeyStorage) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_KeyStorage; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.KeyStorages {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_SubscriberLineNumber struct {
	SubscriberLineNumbers []*TExtensionOnlyType `xml:"SubscriberLineNumber"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_SubscriberLineNumber function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_SubscriberLineNumber instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_SubscriberLineNumber instance.
func (me *XsdGoPkgHasElems_SubscriberLineNumber) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_SubscriberLineNumber; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.SubscriberLineNumbers {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_UserSuffix struct {
	UserSuffixs []*TExtensionOnlyType `xml:"UserSuffix"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_UserSuffix function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_UserSuffix instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_UserSuffix instance.
func (me *XsdGoPkgHasElems_UserSuffix) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_UserSuffix; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.UserSuffixs {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that a password (or passphrase)
//	has been used to
//	authenticate the Principal to a remote system.
type XsdGoPkgHasElems_Password struct {
	//	This element indicates that a password (or passphrase)
	//	has been used to
	//	authenticate the Principal to a remote system.
	Passwords []*TPasswordType `xml:"Password"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_Password function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_Password instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_Password instance.
func (me *XsdGoPkgHasElems_Password) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_Password; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Passwords {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that a Pin (Personal
//	Identification Number) has been used to authenticate the Principal to
//	some local system in order to activate a key.
type XsdGoPkgHasElems_ActivationPin struct {
	//	This element indicates that a Pin (Personal
	//	Identification Number) has been used to authenticate the Principal to
	//	some local system in order to activate a key.
	ActivationPins []*TActivationPinType `xml:"ActivationPin"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_ActivationPin function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_ActivationPin instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_ActivationPin instance.
func (me *XsdGoPkgHasElems_ActivationPin) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_ActivationPin; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.ActivationPins {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that a hardware or software
//	token is used
//	as a method of identifying the Principal.
type XsdGoPkgHasElems_Token struct {
	//	This element indicates that a hardware or software
	//	token is used
	//	as a method of identifying the Principal.
	Tokens []*TokenType `xml:"Token"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_Token function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_Token instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_Token instance.
func (me *XsdGoPkgHasElems_Token) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_Token; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Tokens {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that a time synchronization
//	token is used to identify the Principal. hardware -
//	the time synchonization
//	token has been implemented in hardware. software - the
//	time synchronization
//	token has been implemented in software. SeedLength -
//	the length, in bits, of the
//	random seed used in the time synchronization token.
type XsdGoPkgHasElems_TimeSyncToken struct {
	//	This element indicates that a time synchronization
	//	token is used to identify the Principal. hardware -
	//	the time synchonization
	//	token has been implemented in hardware. software - the
	//	time synchronization
	//	token has been implemented in software. SeedLength -
	//	the length, in bits, of the
	//	random seed used in the time synchronization token.
	TimeSyncTokens []*TimeSyncTokenType `xml:"TimeSyncToken"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_TimeSyncToken function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_TimeSyncToken instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_TimeSyncToken instance.
func (me *XsdGoPkgHasElems_TimeSyncToken) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_TimeSyncToken; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.TimeSyncTokens {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that a smartcard is used to
//	identity the Principal.
type XsdGoPkgHasElems_Smartcard struct {
	//	This element indicates that a smartcard is used to
	//	identity the Principal.
	Smartcards []*TExtensionOnlyType `xml:"Smartcard"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_Smartcard function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_Smartcard instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_Smartcard instance.
func (me *XsdGoPkgHasElems_Smartcard) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_Smartcard; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Smartcards {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates the minimum and/or maximum
//	ASCII length of the password which is enforced (by the UA or the
//	IdP). In other words, this is the minimum and/or maximum number of
//	ASCII characters required to represent a valid password.
//	min - the minimum number of ASCII characters required
//	in a valid password, as enforced by the UA or the IdP.
//	max - the maximum number of ASCII characters required
//	in a valid password, as enforced by the UA or the IdP.
type XsdGoPkgHasElems_Length struct {
	//	This element indicates the minimum and/or maximum
	//	ASCII length of the password which is enforced (by the UA or the
	//	IdP). In other words, this is the minimum and/or maximum number of
	//	ASCII characters required to represent a valid password.
	//	min - the minimum number of ASCII characters required
	//	in a valid password, as enforced by the UA or the IdP.
	//	max - the maximum number of ASCII characters required
	//	in a valid password, as enforced by the UA or the IdP.
	Lengths []*TLengthType `xml:"Length"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_Length function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_Length instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_Length instance.
func (me *XsdGoPkgHasElems_Length) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_Length; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Lengths {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates the length of time for which an
//	PIN-based authentication is valid.
type XsdGoPkgHasElems_ActivationLimit struct {
	//	This element indicates the length of time for which an
	//	PIN-based authentication is valid.
	ActivationLimits []*TActivationLimitType `xml:"ActivationLimit"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_ActivationLimit function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_ActivationLimit instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_ActivationLimit instance.
func (me *XsdGoPkgHasElems_ActivationLimit) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_ActivationLimit; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.ActivationLimits {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Indicates whether the password was chosen by the
//	Principal or auto-supplied by the Authentication Authority.
//	principalchosen - the Principal is allowed to choose
//	the value of the password. This is true even if
//	the initial password is chosen at random by the UA or
//	the IdP and the Principal is then free to change
//	the password.
//	automatic - the password is chosen by the UA or the
//	IdP to be cryptographically strong in some sense,
//	or to satisfy certain password rules, and that the
//	Principal is not free to change it or to choose a new password.
type XsdGoPkgHasElems_Generation struct {
	//	Indicates whether the password was chosen by the
	//	Principal or auto-supplied by the Authentication Authority.
	//	principalchosen - the Principal is allowed to choose
	//	the value of the password. This is true even if
	//	the initial password is chosen at random by the UA or
	//	the IdP and the Principal is then free to change
	//	the password.
	//	automatic - the password is chosen by the UA or the
	//	IdP to be cryptographically strong in some sense,
	//	or to satisfy certain password rules, and that the
	//	Principal is not free to change it or to choose a new password.
	Generations []*TxsdGeneration `xml:"Generation"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_Generation function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_Generation instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_Generation instance.
func (me *XsdGoPkgHasElems_Generation) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_Generation; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Generations {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Refers to those characteristics that define the
//	mechanisms by which the Principal authenticates to the Authentication
//	Authority.
type XsdGoPkgHasElems_AuthnMethod struct {
	//	Refers to those characteristics that define the
	//	mechanisms by which the Principal authenticates to the Authentication
	//	Authority.
	AuthnMethods []*TAuthnMethodBaseType `xml:"AuthnMethod"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_AuthnMethod function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_AuthnMethod instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_AuthnMethod instance.
func (me *XsdGoPkgHasElems_AuthnMethod) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_AuthnMethod; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.AuthnMethods {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The method that a Principal employs to perform
//	authentication to local system components.
type XsdGoPkgHasElems_PrincipalAuthenticationMechanism struct {
	//	The method that a Principal employs to perform
	//	authentication to local system components.
	PrincipalAuthenticationMechanisms []*TPrincipalAuthenticationMechanismType `xml:"PrincipalAuthenticationMechanism"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_PrincipalAuthenticationMechanism function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_PrincipalAuthenticationMechanism instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_PrincipalAuthenticationMechanism instance.
func (me *XsdGoPkgHasElems_PrincipalAuthenticationMechanism) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_PrincipalAuthenticationMechanism; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.PrincipalAuthenticationMechanisms {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The method applied to validate a principal's
//	authentication across a network
type XsdGoPkgHasElems_Authenticator struct {
	//	The method applied to validate a principal's
	//	authentication across a network
	Authenticators []*TAuthenticatorBaseType `xml:"Authenticator"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_Authenticator function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_Authenticator instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_Authenticator instance.
func (me *XsdGoPkgHasElems_Authenticator) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_Authenticator; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Authenticators {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Supports Authenticators with nested combinations of
//	additional complexity.
type XsdGoPkgHasElems_ComplexAuthenticator struct {
	//	Supports Authenticators with nested combinations of
	//	additional complexity.
	ComplexAuthenticators []*TComplexAuthenticatorType `xml:"ComplexAuthenticator"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_ComplexAuthenticator function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_ComplexAuthenticator instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_ComplexAuthenticator instance.
func (me *XsdGoPkgHasElems_ComplexAuthenticator) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_ComplexAuthenticator; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.ComplexAuthenticators {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Indicates that the Principal has been strongly
//	authenticated in a previous session during which the IdP has set a
//	cookie in the UA. During the present session the Principal has only
//	been authenticated by the UA returning the cookie to the IdP.
type XsdGoPkgHasElems_PreviousSession struct {
	//	Indicates that the Principal has been strongly
	//	authenticated in a previous session during which the IdP has set a
	//	cookie in the UA. During the present session the Principal has only
	//	been authenticated by the UA returning the cookie to the IdP.
	PreviousSessions []*TExtensionOnlyType `xml:"PreviousSession"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_PreviousSession function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_PreviousSession instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_PreviousSession instance.
func (me *XsdGoPkgHasElems_PreviousSession) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_PreviousSession; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.PreviousSessions {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Rather like PreviousSession but using stronger
//	security. A secret that was established in a previous session with
//	the Authentication Authority has been cached by the local system and
//	is now re-used (e.g. a Master Secret is used to derive new session
//	keys in TLS, SSL, WTLS).
type XsdGoPkgHasElems_ResumeSession struct {
	//	Rather like PreviousSession but using stronger
	//	security. A secret that was established in a previous session with
	//	the Authentication Authority has been cached by the local system and
	//	is now re-used (e.g. a Master Secret is used to derive new session
	//	keys in TLS, SSL, WTLS).
	ResumeSessions []*TExtensionOnlyType `xml:"ResumeSession"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_ResumeSession function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_ResumeSession instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_ResumeSession instance.
func (me *XsdGoPkgHasElems_ResumeSession) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_ResumeSession; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.ResumeSessions {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Principal has been
//	authenticated by a zero knowledge technique as specified in ISO/IEC
//	9798-5.
type XsdGoPkgHasElems_ZeroKnowledge struct {
	//	This element indicates that the Principal has been
	//	authenticated by a zero knowledge technique as specified in ISO/IEC
	//	9798-5.
	ZeroKnowledges []*TExtensionOnlyType `xml:"ZeroKnowledge"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_ZeroKnowledge function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_ZeroKnowledge instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_ZeroKnowledge instance.
func (me *XsdGoPkgHasElems_ZeroKnowledge) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_ZeroKnowledge; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.ZeroKnowledges {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_SharedSecretChallengeResponse struct {
	SharedSecretChallengeResponses []*TSharedSecretChallengeResponseType `xml:"SharedSecretChallengeResponse"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_SharedSecretChallengeResponse function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_SharedSecretChallengeResponse instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_SharedSecretChallengeResponse instance.
func (me *XsdGoPkgHasElems_SharedSecretChallengeResponse) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_SharedSecretChallengeResponse; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.SharedSecretChallengeResponses {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Principal has been
//	authenticated by a mechanism which involves the Principal computing a
//	digital signature over at least challenge data provided by the IdP.
type XsdGoPkgHasElems_DigSig struct {
	//	This element indicates that the Principal has been
	//	authenticated by a mechanism which involves the Principal computing a
	//	digital signature over at least challenge data provided by the IdP.
	DigSigs []*TPublicKeyType `xml:"DigSig"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_DigSig function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_DigSig instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_DigSig instance.
func (me *XsdGoPkgHasElems_DigSig) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_DigSig; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.DigSigs {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The local system has a private key but it is used
//	in decryption mode, rather than signature mode. For example, the
//	Authentication Authority generates a secret and encrypts it using the
//	local system's public key: the local system then proves it has
//	decrypted the secret.
type XsdGoPkgHasElems_AsymmetricDecryption struct {
	//	The local system has a private key but it is used
	//	in decryption mode, rather than signature mode. For example, the
	//	Authentication Authority generates a secret and encrypts it using the
	//	local system's public key: the local system then proves it has
	//	decrypted the secret.
	AsymmetricDecryptions []*TPublicKeyType `xml:"AsymmetricDecryption"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_AsymmetricDecryption function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_AsymmetricDecryption instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_AsymmetricDecryption instance.
func (me *XsdGoPkgHasElems_AsymmetricDecryption) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_AsymmetricDecryption; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.AsymmetricDecryptions {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The local system has a private key and uses it for
//	shared secret key agreement with the Authentication Authority (e.g.
//	via Diffie Helman).
type XsdGoPkgHasElems_AsymmetricKeyAgreement struct {
	//	The local system has a private key and uses it for
	//	shared secret key agreement with the Authentication Authority (e.g.
	//	via Diffie Helman).
	AsymmetricKeyAgreements []*TPublicKeyType `xml:"AsymmetricKeyAgreement"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_AsymmetricKeyAgreement function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_AsymmetricKeyAgreement instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_AsymmetricKeyAgreement instance.
func (me *XsdGoPkgHasElems_AsymmetricKeyAgreement) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_AsymmetricKeyAgreement; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.AsymmetricKeyAgreements {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Principal has been
//	authenticated through connection from a particular IP address.
type XsdGoPkgHasElems_IPAddress struct {
	//	This element indicates that the Principal has been
	//	authenticated through connection from a particular IP address.
	IPAddresses []*TExtensionOnlyType `xml:"IPAddress"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_IPAddress function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_IPAddress instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_IPAddress instance.
func (me *XsdGoPkgHasElems_IPAddress) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_IPAddress; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.IPAddresses {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The local system and Authentication Authority
//	share a secret key. The local system uses this to encrypt a
//	randomised string to pass to the Authentication Authority.
type XsdGoPkgHasElems_SharedSecretDynamicPlaintext struct {
	//	The local system and Authentication Authority
	//	share a secret key. The local system uses this to encrypt a
	//	randomised string to pass to the Authentication Authority.
	SharedSecretDynamicPlaintexts []*TExtensionOnlyType `xml:"SharedSecretDynamicPlaintext"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_SharedSecretDynamicPlaintext function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_SharedSecretDynamicPlaintext instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_SharedSecretDynamicPlaintext instance.
func (me *XsdGoPkgHasElems_SharedSecretDynamicPlaintext) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_SharedSecretDynamicPlaintext; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.SharedSecretDynamicPlaintexts {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The protocol across which Authenticator information is
//	transferred to an Authentication Authority verifier.
type XsdGoPkgHasElems_AuthenticatorTransportProtocol struct {
	//	The protocol across which Authenticator information is
	//	transferred to an Authentication Authority verifier.
	AuthenticatorTransportProtocols []*TAuthenticatorTransportProtocolType `xml:"AuthenticatorTransportProtocol"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_AuthenticatorTransportProtocol function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_AuthenticatorTransportProtocol instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_AuthenticatorTransportProtocol instance.
func (me *XsdGoPkgHasElems_AuthenticatorTransportProtocol) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_AuthenticatorTransportProtocol; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.AuthenticatorTransportProtocols {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Authenticator has been
//	transmitted using bare HTTP utilizing no additional security
//	protocols.
type XsdGoPkgHasElems_Http struct {
	//	This element indicates that the Authenticator has been
	//	transmitted using bare HTTP utilizing no additional security
	//	protocols.
	Https []*TExtensionOnlyType `xml:"HTTP"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_Http function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_Http instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_Http instance.
func (me *XsdGoPkgHasElems_Http) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_Http; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Https {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Authenticator has been
//	transmitted using a transport mechanism protected by an IPSEC session.
type XsdGoPkgHasElems_IPSec struct {
	//	This element indicates that the Authenticator has been
	//	transmitted using a transport mechanism protected by an IPSEC session.
	IPSecs []*TExtensionOnlyType `xml:"IPSec"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_IPSec function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_IPSec instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_IPSec instance.
func (me *XsdGoPkgHasElems_IPSec) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_IPSec; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.IPSecs {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Authenticator has been
//	transmitted using a transport mechanism protected by a WTLS session.
type XsdGoPkgHasElems_Wtls struct {
	//	This element indicates that the Authenticator has been
	//	transmitted using a transport mechanism protected by a WTLS session.
	Wtlses []*TExtensionOnlyType `xml:"WTLS"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_Wtls function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_Wtls instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_Wtls instance.
func (me *XsdGoPkgHasElems_Wtls) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_Wtls; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Wtlses {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Authenticator has been
//	transmitted solely across a mobile network using no additional
//	security mechanism.
type XsdGoPkgHasElems_MobileNetworkNoEncryption struct {
	//	This element indicates that the Authenticator has been
	//	transmitted solely across a mobile network using no additional
	//	security mechanism.
	MobileNetworkNoEncryptions []*TExtensionOnlyType `xml:"MobileNetworkNoEncryption"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_MobileNetworkNoEncryption function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_MobileNetworkNoEncryption instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_MobileNetworkNoEncryption instance.
func (me *XsdGoPkgHasElems_MobileNetworkNoEncryption) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_MobileNetworkNoEncryption; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.MobileNetworkNoEncryptions {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_MobileNetworkRadioEncryption struct {
	MobileNetworkRadioEncryptions []*TExtensionOnlyType `xml:"MobileNetworkRadioEncryption"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_MobileNetworkRadioEncryption function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_MobileNetworkRadioEncryption instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_MobileNetworkRadioEncryption instance.
func (me *XsdGoPkgHasElems_MobileNetworkRadioEncryption) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_MobileNetworkRadioEncryption; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.MobileNetworkRadioEncryptions {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_MobileNetworkEndToEndEncryption struct {
	MobileNetworkEndToEndEncryptions []*TExtensionOnlyType `xml:"MobileNetworkEndToEndEncryption"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_MobileNetworkEndToEndEncryption function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_MobileNetworkEndToEndEncryption instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_MobileNetworkEndToEndEncryption instance.
func (me *XsdGoPkgHasElems_MobileNetworkEndToEndEncryption) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_MobileNetworkEndToEndEncryption; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.MobileNetworkEndToEndEncryptions {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Authenticator has been
//	transmitted using a transport mechnanism protected by an SSL or TLS
//	session.
type XsdGoPkgHasElems_Ssl struct {
	//	This element indicates that the Authenticator has been
	//	transmitted using a transport mechnanism protected by an SSL or TLS
	//	session.
	Ssls []*TExtensionOnlyType `xml:"SSL"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_Ssl function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_Ssl instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_Ssl instance.
func (me *XsdGoPkgHasElems_Ssl) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_Ssl; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Ssls {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_Pstn struct {
	Pstns []*TExtensionOnlyType `xml:"PSTN"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_Pstn function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_Pstn instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_Pstn instance.
func (me *XsdGoPkgHasElems_Pstn) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_Pstn; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Pstns {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_Isdn struct {
	Isdns []*TExtensionOnlyType `xml:"ISDN"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_Isdn function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_Isdn instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_Isdn instance.
func (me *XsdGoPkgHasElems_Isdn) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_Isdn; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Isdns {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_Adsl struct {
	Adsls []*TExtensionOnlyType `xml:"ADSL"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_Adsl function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_Adsl instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_Adsl instance.
func (me *XsdGoPkgHasElems_Adsl) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_Adsl; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Adsls {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Refers to those characteristics that describe
//	procedural security controls employed by the Authentication Authority.
type XsdGoPkgHasElems_OperationalProtection struct {
	//	Refers to those characteristics that describe
	//	procedural security controls employed by the Authentication Authority.
	OperationalProtections []*TOperationalProtectionType `xml:"OperationalProtection"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_OperationalProtection function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_OperationalProtection instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_OperationalProtection instance.
func (me *XsdGoPkgHasElems_OperationalProtection) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_OperationalProtection; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.OperationalProtections {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_SecurityAudit struct {
	SecurityAudits []*TSecurityAuditType `xml:"SecurityAudit"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_SecurityAudit function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_SecurityAudit instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_SecurityAudit instance.
func (me *XsdGoPkgHasElems_SecurityAudit) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_SecurityAudit; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.SecurityAudits {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_SwitchAudit struct {
	SwitchAudits []*TExtensionOnlyType `xml:"SwitchAudit"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_SwitchAudit function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_SwitchAudit instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_SwitchAudit instance.
func (me *XsdGoPkgHasElems_SwitchAudit) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_SwitchAudit; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.SwitchAudits {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_DeactivationCallCenter struct {
	DeactivationCallCenters []*TExtensionOnlyType `xml:"DeactivationCallCenter"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_DeactivationCallCenter function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_DeactivationCallCenter instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_DeactivationCallCenter instance.
func (me *XsdGoPkgHasElems_DeactivationCallCenter) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_DeactivationCallCenter; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.DeactivationCallCenters {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Provides a mechanism for linking to external (likely
//	human readable) documents in which additional business agreements,
//	(e.g. liability constraints, obligations, etc) can be placed.
type XsdGoPkgHasElems_GoverningAgreements struct {
	//	Provides a mechanism for linking to external (likely
	//	human readable) documents in which additional business agreements,
	//	(e.g. liability constraints, obligations, etc) can be placed.
	GoverningAgreementses []*TGoverningAgreementsType `xml:"GoverningAgreements"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_GoverningAgreements function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_GoverningAgreements instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_GoverningAgreements instance.
func (me *XsdGoPkgHasElems_GoverningAgreements) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_GoverningAgreements; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.GoverningAgreementses {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_GoverningAgreementRef struct {
	GoverningAgreementRef *TGoverningAgreementRefType `xml:"GoverningAgreementRef"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_GoverningAgreementRef function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_GoverningAgreementRef instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_GoverningAgreementRef instance.
func (me *XsdGoPkgHasElem_GoverningAgreementRef) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_GoverningAgreementRef; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.GoverningAgreementRef.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_RestrictedPassword struct {
	RestrictedPasswords []*TRestrictedPasswordType `xml:"RestrictedPassword"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_RestrictedPassword function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_RestrictedPassword instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_RestrictedPassword instance.
func (me *XsdGoPkgHasElems_RestrictedPassword) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_RestrictedPassword; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.RestrictedPasswords {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_Alphabet struct {
	Alphabets []*TAlphabetType `xml:"Alphabet"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_Alphabet function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_Alphabet instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_Alphabet instance.
func (me *XsdGoPkgHasElems_Alphabet) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_Alphabet; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Alphabets {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Key Activation Limit is
//	defined as a specific duration of time.
type XsdGoPkgHasElems_ActivationLimitDuration struct {
	//	This element indicates that the Key Activation Limit is
	//	defined as a specific duration of time.
	ActivationLimitDurations []*TActivationLimitDurationType `xml:"ActivationLimitDuration"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_ActivationLimitDuration function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_ActivationLimitDuration instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_ActivationLimitDuration instance.
func (me *XsdGoPkgHasElems_ActivationLimitDuration) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_ActivationLimitDuration; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.ActivationLimitDurations {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Key Activation Limit is
//	defined as a number of usages.
type XsdGoPkgHasElems_ActivationLimitUsages struct {
	//	This element indicates that the Key Activation Limit is
	//	defined as a number of usages.
	ActivationLimitUsageses []*TActivationLimitUsagesType `xml:"ActivationLimitUsages"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_ActivationLimitUsages function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_ActivationLimitUsages instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_ActivationLimitUsages instance.
func (me *XsdGoPkgHasElems_ActivationLimitUsages) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_ActivationLimitUsages; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.ActivationLimitUsageses {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	This element indicates that the Key Activation Limit is
//	the session.
type XsdGoPkgHasElems_ActivationLimitSession struct {
	//	This element indicates that the Key Activation Limit is
	//	the session.
	ActivationLimitSessions []*TActivationLimitSessionType `xml:"ActivationLimitSession"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_ActivationLimitSession function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_ActivationLimitSession instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_ActivationLimitSession instance.
func (me *XsdGoPkgHasElems_ActivationLimitSession) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_ActivationLimitSession; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.ActivationLimitSessions {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_Extension struct {
	Extension *TExtensionType `xml:"Extension"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_Extension function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_Extension instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_Extension instance.
func (me *XsdGoPkgHasElem_Extension) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_Extension; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschema_Length_TRestrictedLengthType_ struct {
	Lengths []*TRestrictedLengthType `xml:"Length"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschema_Length_TRestrictedLengthType_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschema_Length_TRestrictedLengthType_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschema_Length_TRestrictedLengthType_ instance.
func (me *XsdGoPkgHasElems_LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschema_Length_TRestrictedLengthType_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschema_Length_TRestrictedLengthType_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Lengths {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasCdata struct {
	XsdGoPkgCDATA string `xml:",chardata"`
}

//	If the WalkHandlers.XsdGoPkgHasCdata function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasCdata instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasCdata instance.
func (me *XsdGoPkgHasCdata) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasCdata; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

var (
	//	Set this to false to break a Walk() immediately as soon as the first error is returned by a custom handler function.
	//	If true, Walk() proceeds and accumulates all errors in the WalkErrors slice.
	WalkContinueOnError = true
	//	Contains all errors accumulated during Walk()s. If you're using this, you need to reset this yourself as needed prior to a fresh Walk().
	WalkErrors []error
	//	Your custom error-handling function, if required.
	WalkOnError func(error)
	//	Provides 152 strong-typed hooks for your own custom handler functions to be invoked when the Walk() method is called on any instance of any (non-attribute-related) struct type defined in this package.
	//	If your custom handler does get called at all for a given struct instance, then it always gets called twice, first with the 'enter' bool argument set to true, then (after having Walk()ed all subordinate struct instances, if any) once again with it set to false.
	WalkHandlers = &XsdGoPkgWalkHandlers{}
)

//	Provides 152 strong-typed hooks for your own custom handler functions to be invoked when the Walk() method is called on any instance of any (non-attribute-related) struct type defined in this package.
//	If your custom handler does get called at all for a given struct instance, then it always gets called twice, first with the 'enter' bool argument set to true, then (after having Walk()ed all subordinate struct instances, if any) once again with it set to false.
type XsdGoPkgWalkHandlers struct {
	XsdGoPkgHasElem_ActivationLimit                                                                                    func(*XsdGoPkgHasElem_ActivationLimit, bool) error
	TKeyStorageType                                                                                                    func(*TKeyStorageType, bool) error
	XsdGoPkgHasElem_PrivateKeyProtection                                                                               func(*XsdGoPkgHasElem_PrivateKeyProtection, bool) error
	XsdGoPkgHasElem_PrincipalAuthenticationMechanism                                                                   func(*XsdGoPkgHasElem_PrincipalAuthenticationMechanism, bool) error
	XsdGoPkgHasElem_SharedSecretDynamicPlaintext                                                                       func(*XsdGoPkgHasElem_SharedSecretDynamicPlaintext, bool) error
	XsdGoPkgHasElems_ComplexAuthenticator                                                                              func(*XsdGoPkgHasElems_ComplexAuthenticator, bool) error
	XsdGoPkgHasElem_TechnicalProtection                                                                                func(*XsdGoPkgHasElem_TechnicalProtection, bool) error
	XsdGoPkgHasElem_AuthenticationContextDeclaration                                                                   func(*XsdGoPkgHasElem_AuthenticationContextDeclaration, bool) error
	XsdGoPkgHasElems_UserSuffix                                                                                        func(*XsdGoPkgHasElems_UserSuffix, bool) error
	XsdGoPkgHasElems_SharedSecretDynamicPlaintext                                                                      func(*XsdGoPkgHasElems_SharedSecretDynamicPlaintext, bool) error
	XsdGoPkgHasElem_Generation                                                                                         func(*XsdGoPkgHasElem_Generation, bool) error
	XsdGoPkgHasElem_ActivationLimitDuration                                                                            func(*XsdGoPkgHasElem_ActivationLimitDuration, bool) error
	XsdGoPkgHasElem_Token                                                                                              func(*XsdGoPkgHasElem_Token, bool) error
	XsdGoPkgHasElem_AuthenticatorTransportProtocol                                                                     func(*XsdGoPkgHasElem_AuthenticatorTransportProtocol, bool) error
	XsdGoPkgHasElems_Smartcard                                                                                         func(*XsdGoPkgHasElems_Smartcard, bool) error
	XsdGoPkgHasElems_Generation                                                                                        func(*XsdGoPkgHasElems_Generation, bool) error
	XsdGoPkgHasElems_MobileNetworkEndToEndEncryption                                                                   func(*XsdGoPkgHasElems_MobileNetworkEndToEndEncryption, bool) error
	TActivationLimitDurationType                                                                                       func(*TActivationLimitDurationType, bool) error
	XsdGoPkgHasElem_MobileNetworkEndToEndEncryption                                                                    func(*XsdGoPkgHasElem_MobileNetworkEndToEndEncryption, bool) error
	XsdGoPkgHasElems_SharedSecretChallengeResponse                                                                     func(*XsdGoPkgHasElems_SharedSecretChallengeResponse, bool) error
	TGoverningAgreementRefType                                                                                         func(*TGoverningAgreementRefType, bool) error
	XsdGoPkgHasElem_ActivationLimitSession                                                                             func(*XsdGoPkgHasElem_ActivationLimitSession, bool) error
	TSecurityAuditType                                                                                                 func(*TSecurityAuditType, bool) error
	TPasswordType                                                                                                      func(*TPasswordType, bool) error
	XsdGoPkgHasGroup_AuthenticatorChoiceGroup                                                                          func(*XsdGoPkgHasGroup_AuthenticatorChoiceGroup, bool) error
	XsdGoPkgHasElem_Pstn                                                                                               func(*XsdGoPkgHasElem_Pstn, bool) error
	XsdGoPkgHasElems_Length                                                                                            func(*XsdGoPkgHasElems_Length, bool) error
	XsdGoPkgHasElems_MobileNetworkRadioEncryption                                                                      func(*XsdGoPkgHasElems_MobileNetworkRadioEncryption, bool) error
	XsdGoPkgHasElems_SecurityAudit                                                                                     func(*XsdGoPkgHasElems_SecurityAudit, bool) error
	XsdGoPkgHasElems_SwitchAudit                                                                                       func(*XsdGoPkgHasElems_SwitchAudit, bool) error
	XsdGoPkgHasElems_GoverningAgreementRef                                                                             func(*XsdGoPkgHasElems_GoverningAgreementRef, bool) error
	TxsdGeneration                                                                                                     func(*TxsdGeneration, bool) error
	XsdGoPkgHasElem_SecretKeyProtection                                                                                func(*XsdGoPkgHasElem_SecretKeyProtection, bool) error
	XsdGoPkgHasElem_RestrictedPassword                                                                                 func(*XsdGoPkgHasElem_RestrictedPassword, bool) error
	XsdGoPkgHasElems_WrittenConsent                                                                                    func(*XsdGoPkgHasElems_WrittenConsent, bool) error
	XsdGoPkgHasElems_Authenticator                                                                                     func(*XsdGoPkgHasElems_Authenticator, bool) error
	TGoverningAgreementsType                                                                                           func(*TGoverningAgreementsType, bool) error
	XsdGoPkgHasElem_Password                                                                                           func(*XsdGoPkgHasElem_Password, bool) error
	XsdGoPkgHasElem_ResumeSession                                                                                      func(*XsdGoPkgHasElem_ResumeSession, bool) error
	TAuthnMethodBaseType                                                                                               func(*TAuthnMethodBaseType, bool) error
	XsdGoPkgHasElems_IPSec                                                                                             func(*XsdGoPkgHasElems_IPSec, bool) error
	XsdGoPkgHasElems_RestrictedPassword                                                                                func(*XsdGoPkgHasElems_RestrictedPassword, bool) error
	XsdGoPkgHasElems_ActivationLimitSession                                                                            func(*XsdGoPkgHasElems_ActivationLimitSession, bool) error
	TLengthType                                                                                                        func(*TLengthType, bool) error
	XsdGoPkgHasElem_KeySharing                                                                                         func(*XsdGoPkgHasElem_KeySharing, bool) error
	XsdGoPkgHasElem_DeactivationCallCenter                                                                             func(*XsdGoPkgHasElem_DeactivationCallCenter, bool) error
	XsdGoPkgHasElem_UserSuffix                                                                                         func(*XsdGoPkgHasElem_UserSuffix, bool) error
	XsdGoPkgHasElem_AuthnMethod                                                                                        func(*XsdGoPkgHasElem_AuthnMethod, bool) error
	XsdGoPkgHasElems_PrivateKeyProtection                                                                              func(*XsdGoPkgHasElems_PrivateKeyProtection, bool) error
	XsdGoPkgHasElems_Wtls                                                                                              func(*XsdGoPkgHasElems_Wtls, bool) error
	TRestrictedPasswordType                                                                                            func(*TRestrictedPasswordType, bool) error
	TimeSyncTokenType                                                                                                  func(*TimeSyncTokenType, bool) error
	XsdGoPkgHasElem_SubscriberLineNumber                                                                               func(*XsdGoPkgHasElem_SubscriberLineNumber, bool) error
	XsdGoPkgHasElem_Ssl                                                                                                func(*XsdGoPkgHasElem_Ssl, bool) error
	XsdGoPkgHasElem_MobileNetworkRadioEncryption                                                                       func(*XsdGoPkgHasElem_MobileNetworkRadioEncryption, bool) error
	XsdGoPkgHasElem_MobileNetworkNoEncryption                                                                          func(*XsdGoPkgHasElem_MobileNetworkNoEncryption, bool) error
	TAuthnContextDeclarationBaseType                                                                                   func(*TAuthnContextDeclarationBaseType, bool) error
	XsdGoPkgHasElems_AuthenticationContextDeclaration                                                                  func(*XsdGoPkgHasElems_AuthenticationContextDeclaration, bool) error
	XsdGoPkgHasElems_Password                                                                                          func(*XsdGoPkgHasElems_Password, bool) error
	XsdGoPkgHasCdata                                                                                                   func(*XsdGoPkgHasCdata, bool) error
	TActivationLimitType                                                                                               func(*TActivationLimitType, bool) error
	TokenType                                                                                                          func(*TokenType, bool) error
	XsdGoPkgHasElems_KeyActivation                                                                                     func(*XsdGoPkgHasElems_KeyActivation, bool) error
	XsdGoPkgHasElems_DeactivationCallCenter                                                                            func(*XsdGoPkgHasElems_DeactivationCallCenter, bool) error
	XsdGoPkgHasElems_Extension                                                                                         func(*XsdGoPkgHasElems_Extension, bool) error
	TxsdPhysicalVerification                                                                                           func(*TxsdPhysicalVerification, bool) error
	XsdGoPkgHasGroup_AuthenticatorSequenceGroup                                                                        func(*XsdGoPkgHasGroup_AuthenticatorSequenceGroup, bool) error
	XsdGoPkgHasElem_ComplexAuthenticator                                                                               func(*XsdGoPkgHasElem_ComplexAuthenticator, bool) error
	XsdGoPkgHasElems_Isdn                                                                                              func(*XsdGoPkgHasElems_Isdn, bool) error
	TPrivateKeyProtectionType                                                                                          func(*TPrivateKeyProtectionType, bool) error
	XsdGoPkgHasElem_LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschema_Length_TRestrictedLengthType_  func(*XsdGoPkgHasElem_LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschema_Length_TRestrictedLengthType_, bool) error
	XsdGoPkgHasElems_SubscriberLineNumber                                                                              func(*XsdGoPkgHasElems_SubscriberLineNumber, bool) error
	TExtensionType                                                                                                     func(*TExtensionType, bool) error
	TRestrictedLengthType                                                                                              func(*TRestrictedLengthType, bool) error
	XsdGoPkgHasElem_AsymmetricDecryption                                                                               func(*XsdGoPkgHasElem_AsymmetricDecryption, bool) error
	XsdGoPkgHasElem_Adsl                                                                                               func(*XsdGoPkgHasElem_Adsl, bool) error
	XsdGoPkgHasElems_ZeroKnowledge                                                                                     func(*XsdGoPkgHasElems_ZeroKnowledge, bool) error
	XsdGoPkgHasElem_ActivationLimitUsages                                                                              func(*XsdGoPkgHasElem_ActivationLimitUsages, bool) error
	TKeySharingType                                                                                                    func(*TKeySharingType, bool) error
	XsdGoPkgHasElem_ZeroKnowledge                                                                                      func(*XsdGoPkgHasElem_ZeroKnowledge, bool) error
	XsdGoPkgHasElem_Wtls                                                                                               func(*XsdGoPkgHasElem_Wtls, bool) error
	XsdGoPkgHasElems_KeySharing                                                                                        func(*XsdGoPkgHasElems_KeySharing, bool) error
	XsdGoPkgHasElems_Adsl                                                                                              func(*XsdGoPkgHasElems_Adsl, bool) error
	XsdGoPkgHasElem_Http                                                                                               func(*XsdGoPkgHasElem_Http, bool) error
	XsdGoPkgHasElems_Ssl                                                                                               func(*XsdGoPkgHasElems_Ssl, bool) error
	TIdentificationType                                                                                                func(*TIdentificationType, bool) error
	TAlphabetType                                                                                                      func(*TAlphabetType, bool) error
	TActivationLimitUsagesType                                                                                         func(*TActivationLimitUsagesType, bool) error
	XsdGoPkgHasElem_GoverningAgreementRef                                                                              func(*XsdGoPkgHasElem_GoverningAgreementRef, bool) error
	XsdGoPkgHasElem_KeyStorage                                                                                         func(*XsdGoPkgHasElem_KeyStorage, bool) error
	XsdGoPkgHasElem_DigSig                                                                                             func(*XsdGoPkgHasElem_DigSig, bool) error
	XsdGoPkgHasElems_Token                                                                                             func(*XsdGoPkgHasElems_Token, bool) error
	XsdGoPkgHasElems_AuthnMethod                                                                                       func(*XsdGoPkgHasElems_AuthnMethod, bool) error
	XsdGoPkgHasElems_Pstn                                                                                              func(*XsdGoPkgHasElems_Pstn, bool) error
	XsdGoPkgHasElems_GoverningAgreements                                                                               func(*XsdGoPkgHasElems_GoverningAgreements, bool) error
	XsdGoPkgHasElems_Alphabet                                                                                          func(*XsdGoPkgHasElems_Alphabet, bool) error
	XsdGoPkgHasElems_ActivationLimitDuration                                                                           func(*XsdGoPkgHasElems_ActivationLimitDuration, bool) error
	TExtensionOnlyType                                                                                                 func(*TExtensionOnlyType, bool) error
	XsdGoPkgHasElems_PhysicalVerification                                                                              func(*XsdGoPkgHasElems_PhysicalVerification, bool) error
	XsdGoPkgHasElems_OperationalProtection                                                                             func(*XsdGoPkgHasElems_OperationalProtection, bool) error
	TComplexAuthenticatorType                                                                                          func(*TComplexAuthenticatorType, bool) error
	XsdGoPkgHasElems_LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschema_Length_TRestrictedLengthType_ func(*XsdGoPkgHasElems_LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschema_Length_TRestrictedLengthType_, bool) error
	TechnicalProtectionBaseType                                                                                        func(*TechnicalProtectionBaseType, bool) error
	TOperationalProtectionType                                                                                         func(*TOperationalProtectionType, bool) error
	XsdGoPkgHasElem_OperationalProtection                                                                              func(*XsdGoPkgHasElem_OperationalProtection, bool) error
	XsdGoPkgHasElem_SharedSecretChallengeResponse                                                                      func(*XsdGoPkgHasElem_SharedSecretChallengeResponse, bool) error
	XsdGoPkgHasElems_DigSig                                                                                            func(*XsdGoPkgHasElems_DigSig, bool) error
	XsdGoPkgHasElem_PhysicalVerification                                                                               func(*XsdGoPkgHasElem_PhysicalVerification, bool) error
	XsdGoPkgHasElems_Identification                                                                                    func(*XsdGoPkgHasElems_Identification, bool) error
	XsdGoPkgHasElems_ResumeSession                                                                                     func(*XsdGoPkgHasElems_ResumeSession, bool) error
	XsdGoPkgHasElem_ActivationPin                                                                                      func(*XsdGoPkgHasElem_ActivationPin, bool) error
	XsdGoPkgHasElem_SwitchAudit                                                                                        func(*XsdGoPkgHasElem_SwitchAudit, bool) error
	XsdGoPkgHasElem_IPAddress                                                                                          func(*XsdGoPkgHasElem_IPAddress, bool) error
	XsdGoPkgHasElem_PreviousSession                                                                                    func(*XsdGoPkgHasElem_PreviousSession, bool) error
	XsdGoPkgHasElems_AsymmetricKeyAgreement                                                                            func(*XsdGoPkgHasElems_AsymmetricKeyAgreement, bool) error
	XsdGoPkgHasElem_AsymmetricKeyAgreement                                                                             func(*XsdGoPkgHasElem_AsymmetricKeyAgreement, bool) error
	XsdGoPkgHasElem_IPSec                                                                                              func(*XsdGoPkgHasElem_IPSec, bool) error
	XsdGoPkgHasElems_AsymmetricDecryption                                                                              func(*XsdGoPkgHasElems_AsymmetricDecryption, bool) error
	XsdGoPkgHasElems_AuthenticatorTransportProtocol                                                                    func(*XsdGoPkgHasElems_AuthenticatorTransportProtocol, bool) error
	TActivationLimitSessionType                                                                                        func(*TActivationLimitSessionType, bool) error
	XsdGoPkgHasElem_Smartcard                                                                                          func(*XsdGoPkgHasElem_Smartcard, bool) error
	XsdGoPkgHasElems_ActivationPin                                                                                     func(*XsdGoPkgHasElems_ActivationPin, bool) error
	XsdGoPkgHasElems_PrincipalAuthenticationMechanism                                                                  func(*XsdGoPkgHasElems_PrincipalAuthenticationMechanism, bool) error
	XsdGoPkgHasElem_GoverningAgreements                                                                                func(*XsdGoPkgHasElem_GoverningAgreements, bool) error
	XsdGoPkgHasElem_WrittenConsent                                                                                     func(*XsdGoPkgHasElem_WrittenConsent, bool) error
	TSecretKeyProtectionType                                                                                           func(*TSecretKeyProtectionType, bool) error
	XsdGoPkgHasElems_TechnicalProtection                                                                               func(*XsdGoPkgHasElems_TechnicalProtection, bool) error
	XsdGoPkgHasElem_Length                                                                                             func(*XsdGoPkgHasElem_Length, bool) error
	XsdGoPkgHasElem_KeyActivation                                                                                      func(*XsdGoPkgHasElem_KeyActivation, bool) error
	XsdGoPkgHasElem_SecurityAudit                                                                                      func(*XsdGoPkgHasElem_SecurityAudit, bool) error
	TAuthenticatorBaseType                                                                                             func(*TAuthenticatorBaseType, bool) error
	XsdGoPkgHasElems_SecretKeyProtection                                                                               func(*XsdGoPkgHasElems_SecretKeyProtection, bool) error
	XsdGoPkgHasElems_ActivationLimit                                                                                   func(*XsdGoPkgHasElems_ActivationLimit, bool) error
	XsdGoPkgHasElem_Extension                                                                                          func(*XsdGoPkgHasElem_Extension, bool) error
	TSharedSecretChallengeResponseType                                                                                 func(*TSharedSecretChallengeResponseType, bool) error
	XsdGoPkgHasElem_Isdn                                                                                               func(*XsdGoPkgHasElem_Isdn, bool) error
	XsdGoPkgHasElems_MobileNetworkNoEncryption                                                                         func(*XsdGoPkgHasElems_MobileNetworkNoEncryption, bool) error
	XsdGoPkgHasElems_ActivationLimitUsages                                                                             func(*XsdGoPkgHasElems_ActivationLimitUsages, bool) error
	XsdGoPkgHasElem_Identification                                                                                     func(*XsdGoPkgHasElem_Identification, bool) error
	TKeyActivationType                                                                                                 func(*TKeyActivationType, bool) error
	XsdGoPkgHasElem_TimeSyncToken                                                                                      func(*XsdGoPkgHasElem_TimeSyncToken, bool) error
	TPublicKeyType                                                                                                     func(*TPublicKeyType, bool) error
	XsdGoPkgHasElem_Authenticator                                                                                      func(*XsdGoPkgHasElem_Authenticator, bool) error
	TAuthenticatorTransportProtocolType                                                                                func(*TAuthenticatorTransportProtocolType, bool) error
	XsdGoPkgHasElems_KeyStorage                                                                                        func(*XsdGoPkgHasElems_KeyStorage, bool) error
	XsdGoPkgHasElems_TimeSyncToken                                                                                     func(*XsdGoPkgHasElems_TimeSyncToken, bool) error
	XsdGoPkgHasElems_IPAddress                                                                                         func(*XsdGoPkgHasElems_IPAddress, bool) error
	XsdGoPkgHasElems_Http                                                                                              func(*XsdGoPkgHasElems_Http, bool) error
	XsdGoPkgHasElem_Alphabet                                                                                           func(*XsdGoPkgHasElem_Alphabet, bool) error
	TActivationPinType                                                                                                 func(*TActivationPinType, bool) error
	TPrincipalAuthenticationMechanismType                                                                              func(*TPrincipalAuthenticationMechanismType, bool) error
	XsdGoPkgHasElems_PreviousSession                                                                                   func(*XsdGoPkgHasElems_PreviousSession, bool) error
}
